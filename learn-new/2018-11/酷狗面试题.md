#### 0、**对于评述算法优劣术语的说明**:smile:

- **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；

- **不稳定**：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；

- **内排序**：所有排序操作都在内存中完成；

- **外排序**：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；

- **时间复杂度**: 一个算法执行所耗费的时间。

- **空间复杂度**: 运行完一个程序所需内存的大小。

  

#### 1. CSS 实现三栏布局（左右两边固定宽度，中间自适应）？:smile:

> 1. 使用flex布局： 父元素设置 `display: flex`，左右两边设置固定宽度，中间设置 `flex-grow: 1`；
>
>    ~~~css
>    .main {
>      display: flex;
>    }
>    .center {
>      flex: 1 1 auto;
>    }
>    .left {
>      width: 100px;
>    }
>    .right {
>      widht: 100px;
>    }
>    ~~~
>
> 2. 使用浮动布局：左右两边设置固定宽度，而且分别设置 `float:left和right`，这个方法有一个需要注意的是在HTML中，中间栏需要和右边栏进行对调；
>
>    ~~~css
>    .main {
>      overflow: hidden;
>    }
>    .left {
>      float: left;
>    }
>    .right {
>      float: right:
>    }
>    ~~~
>
> 3. 使用绝对定位布局：左右两边设置固定宽度和 `position:absolute`,而且分别设置 `left: 0`和 `right: 0`，中间栏只要设置左右margin为左右栏的宽度就可以了（需要注意的是左右两边需要设置 `top: 0`，不然右边会被订下来）
>
>    ~~~css
>    .main {
>      position: relative;
>    }
>    .center {
>      margin: 0px 100px;
>    }
>    .left, .right {
>      position: absolute;
>      top: 0;
>    }
>    .left {
>      left: 0;
>    }
>    .right {
>      right: 0;
>    }
>    ~~~

#### 2. CSS 如何实现弹窗水平垂直居中？(文本和块级元素，垂直居中，水平居中):smile:

~~~css
/* 文本 */
      height: 100px;
      line-height: 100px;
      text-align: center;
/* 块级 */
      display: flex;
      justify-content: center;
      align-items: center;
~~~

#### 3. `==`和 `===` 的区别:smile:

> `===`为恒等符：当等号两边的值为相同类型的时候，直接比较等号两边的值，值相同则返回true，若等号两边的值类型不同时直接返回false。
>
> `==`为等值符： 当等号两边的值为相同类型时比较值是否相同，类型不同时会发生类型的自动转换，转换为相同的类型后再作比较。
> a、如果一个是null、一个是undefined，那么[相等]。
>
> ~~~js
> console.log(null == undefined); // true
> ~~~
>
> b、如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。
> c、如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。
> d、如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方法。 js核心内置类，会尝试valueOf先于toString；例外的是Date，Date利用的是toString转换。
> e、任何其他组合，都[不相等]。

#### 4. 30 `==` '30' 的过程是怎样的？:smile:

> 1. 30为数值类型，而'30'字符串类型，因此等号两边的数据类型不相等，需要进行转换类型；
> 2. 由于一个是数值，另一个字符串，所以需要将字符串转换成数值再进行比较，即 `'30' => 30`;
> 3. 这时等号两边同样为数值型数据，即 `30 == 30`，所以返回 `true`

#### 5. 以下代码输出的是什么？为什么呢？:smile:

```js
for (var i=0; i<5; i++) {
  setTimeout( function timer() {
    console.log(i); 
  }, 0);
}
```

自己：结果是5个5；原因：setTimeout内部的代码不会立即执行（虽然设置的是0ms），这部分代码会存放在一个序列中。当循环结束， i = 5；代码执行完毕，此时输出5个5；

标准：浏览器是多线程的（JS引擎线程，render线程，事件监听线程，http请求线程），但是 JS 代码在执行中是单线程的（除去ajax请求部分）；所以JS代码执行过程中会发生阻塞；setTimeout内部的代码被阻塞，直到全部的代码执行完毕后，settimeout 的代码才开始执行。——实际上内部代码执行的时间不是0毫秒后。

#### 6. 你有使用过闭包吗？

#### 7. 模块化的异步加载怎样做？

#### 8. `window.onload`执行时间？

#### 9.图片加载完的时候会执行吗？

#### 10. 了解JS继承吗？

#### 11. 利用原型链的继承有什么缺点吗？

#### 12. 知道如何修改this的指向吗？

> 修改this指向的办法有三种： `apply`、 `call`和 `bind`
> `apply`、 `call`：通过传入需要指向的对象，从而改变 `this`的指向，指向传入的第一个参数;
> `bind`：它会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。

```
window.color = 'red';var o = { color:'blue' };function sayColor(){    console.log(this.color);}var globalSaycolor = sayColor;var objectSaycolor = sayColor.bind(o);globalSaycolor();  // redobjectSaycolor();  // blue
```

**补充**

> 其实还有一种：**new关键字改变this指向**
> 因为在 `new`的过程中，其中有一个步骤为将构造函数内部的 `this`指向实例对象，所以通过 `new关键字`也可以改变 `this`的指向。

#### 13. `apply`和 `call`的区别？

> **相同点：**可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为由thisObj指定的新对象。
>
> **不同点：**实际上， `apply`和 `call`的功能是一样的，只是传入的参数列表形式不同。
> `apply`：最多只能有两个参数——新 `this`对象和一个数组 `argArray`。如果给该方法传递多个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里。如果 `argArray`不是一个有效的数组或 `arguments`对象，那么将导致一个 `TypeError`。如果没有提供 `argArray`和 `thisObj`任何一个参数，那么Global对象将被用作 `thisObj`，并且无法被传递任何参数。
>
> `call`：它可以接受多个参数，第一个参数与 `apply`一样，后面则是一串参数列表。这个方法主要用在js对象各方法相互调用的时候，使当前this实例指针保持一致，或者在特殊情况下需要改变this指针。如果没有提供 `thisObj`参数，那么 Global 对象被用作 `thisObj`。

#### 14. 有一个按钮是异步生成的，怎样对它进行事件绑定？

> 由于按钮是异步生成的，所以我选择将事件绑定在按钮生成的父元素上，通过事件委托的机制，利用事件冒泡，把事件绑定在父元素上，可以通过判断 `event.target`按钮是否已经生成，从而实现相应的事件。
>
> 科普补充：
> **事件冒泡**可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到 `document`对象；
> **事件捕获**则跟事件冒泡相反，事件会从 `document`对象开始发生，直到最具体的元素；

#### 15. 跨域有处理过吗？

> 我处理过的跨域有两种情况：
>
> 1. 一种是在页面中嵌入了一个iframe，因此父子iframe间产生了跨域，要解决这个问题，只需要把 `document.domain`设置成相同的值就可以在两个页面里进行相应的操作了；
> 2. 另外一种情况是用Vue开发涉及到的跨域问题，这个问题只需要修改config文件夹下的index.js中的dev:{}部分中修改proxyTable参数即可，相当于对跨域的url进行了代理，从而可以顺利访问。
>
> 另外说了一下自己比较熟悉的一种跨域解决方案：JSONP
> JSONP解决跨域问题的本质其实就是 `<script>` 标签可以请求不同域名下的资源，即 `<script>` 请求不受浏览器同源策略影响。

**面试官听到JSONP立刻提出了一个问题：JSONP是否可以支持 POST方法？为什么？**

> JSONP只支持 `GET`的请求方法，上面也提到了JSONP原理其实就是利用 `<script>` 标签发送了一个 `URL`给服务器，其实与 `ajax XMLHttpRequest`协议无关了，相当于输入了一个 `url`而已，所以必然只能为 `GET`请求方法。

#### 16. 既然提到 `POST`和 `GET`，说说两者的区别？

> 1. 大小： `GET`提交的数据最大为2k（原则上url长度无限制，可是浏览器通常限制url长度在2k左右）； `POST`理论上没有限制大小（实际上IIS4中最大量为80KB，IIS5中为100KB）。
> 2. 发送方式： `GET`请求数据放在url上，即HTTP协议头中，其格式为： `url?key=value&key2=value`; `POST`把数据放在HTTP的包体中（Request Body）。
> 3. 安全性： `GET`请求可被缓存，请求保存在浏览器历史记录中； `POST`则不能被缓存。与 `POST`相比， `GET`的安全性较差，因为发送的数据是URL的一部分。
> 4. **发送TCP包**：对 `GET`请求只**产生一个TCP包**，浏览器会把 `http header`和 `data`一并发送出去，服务器响应 `200`（返回数据）；对于 `POST`请求**产生两个TCP数据包**，浏览器先发送 `http header`，服务器确认权限正确响应 `100`(continue)返回浏览器，浏览器收到 `100`确认继续请求，再次发送 `data`，服务器响应 `200`（返回数据）。

#### 17. 听到你提到浏览器，你了解浏览器缓存的方式吗？

#### 18. 看你有用过Promise，知道Promise有几种状态？

#### 19. 你知道 `pending`状态可以停止吗？

#### 20. 那XMLHttpRequest 的 `pending`状态可以停止吗？

#### 21. 知道Promise和setTimeout的执行顺序吗？

#### 22. vue中生命周期中的钩子函数用过哪些？

#### 23. 为什么不把数据放在created函数中？

#### 24. 对Vue的数据双向绑定有了解吗？

#### 25. 了解重绘和回流吗？页面的加载顺序？

#### 26. 如何减少回流、重绘？怎样控制只有一部分回流？

#### 27. 了解什么算法？快排？

#### 28. 还了解什么排序算法？

#### 29. 了解二叉查找树吗？

#### 30. 有了解什么后端语言吗？知道面向对象的特性吗？

#### 31. 知道数据库连接池吗？

#### 32. 未来前端的规划？





#### 3. 理解的HTTP状态码有哪些？

#### 4. 正则的题目，对比 `/^[a-z0-9][a-z]+$/`和 `/^[a-z0-9][a-z]*$/`的区别？

#### 5. `display:none` 和 `visibility:hidden`的区别？

#### 6. CSS选择器的理解，你知道多少选择器？

#### 7. CSS3布局，移动端有用过rem吗？布局的话一般怎样布局？

#### 8. Flex布局和传统的其他布局有什么优点？

#### 9. Flex的居中方式有哪些？其他方式有哪些？

#### 10. display设置inline-block的话，多个之间有间隔应该怎样处理？ (父节点font-size: 0)

#### 11. 更熟悉那方面的技术栈？

#### 12. 对自己项目是怎样设计和选型的？

#### 13. 有用到vuex吗？

#### 14. 组件之间的通讯怎样做到？

#### 15. 真的学习前端是什么时候开始？

#### 16. 方向是选择全栈还是只做前端？

#### 17. 有没有在nodeJS上做过什么？

#### 18. 有没有在npm上面做过开源的学习？

 



### 阿里前端要求

职位描述：1. 负责移动端信息流推荐/搜索，以及PC端管理后台交互功能的构建 2. 参与整体项目计划制定，项目需求分析，跟踪项目进度，评估项目风险，对产品及运营需求进行技术方案设计、实现与持续优化； 3. 过程中，对业务目标及技术目标的达成负责，对问题快速响应，利用工程化的手段提高研发效率、质量。

任职要求：

1. 三年以上 Web 前端研发经验，参与过比较复杂的前端交互场景，熟练掌握 HTML/CSS/JavaScript；
2. 前端框架：VUE or React 
3. 具备前端全栈开发能力，熟练掌握Node.js 以及脚手架Express or Koa ，熟悉 Linux 系统运维； 



## 掌握react，这一篇就够了





# jsx语法

前端MVVM主流框架都有一套自己的模板处理方法，react则使用它独特的jsx语法。在组件中插入html类似的语法，简化创建view的流程。

下面让我们来认识一下构建的两种元素

## 原生元素

```
ReactDOM.render((  <div>    <h1>标题</h1>  </div>), document.getElementById('root'))
```

通过简单的语法页面就会被插入一个div+一个h1标签。原生的html元素可以被直接使用。以上的语法并不是js支持的语法，需要被转换之后才能运行。

## 自定义元素

react强大之处就在于可以组件的自定义，实现组件的复用。如果我们创建了一个组件。我们也可以通过jsx语法调用。

```
import * as React from 'react'class Page extends React.Component {  render() {    return (<div>      home111 &copy; © \ua9    </div>)  }}ReactDOM.render((  <div>    <Page/>  </div>), document.getElementById('root'))
```

我们定义了一个Page组件，可以在jsx里面像调用html一样直接调用。

## 插入动态数据

```
let name = 'hi'ReactDOM.render((  <div>    {name}  </div>), document.getElementById('root'))
```

使用{}就可以插入数据，但是{}中间的必须是js表达式，不能是语句。如果表达式的执行结果是一个数组，则会自动join。

## 注释

jsx语法和html语法一样，也是可以插入注释，只不过写的时候有一些区别

### 子组件注释

```
let name = 'hi'ReactDOM.render((  <div>    {/* 注释 */}    {name}  </div>), document.getElementById('root'))
```

在子组件中插入注释，需要使用{}包裹起来，在//之间插入注释文字。

### 属性注释

```
let name = 'hi'ReactDOM.render((  <div>    {name}    <img /*         多行注释    */ src="1.jpg"/>  </div>), document.getElementById('root'))
```

在标签中间，可以插入一个多行注释，类似上面的代码。

## 属性props

1. 可以向使用html的attr一样使用属性，就像下面img的src一样

```
let name = 'hi'ReactDOM.render((  <div>    <img src="1.png"/>  </div>), document.getElementById('root'))
```

1. 如果需要传递动态属性，使用{}，多个属性，使用展开运算符

```
let props = {    src: '1.png',    alt: '1图片'}ReactDOM.render((  <div>    <img src={"1.png"}/>    <img {...props}/>  </div>), document.getElementById('root'))
```

1. 两个转换,class-->className for-->htmlFor

因为class和for是javascript关键字，所以这里需要用转换之后名称

```
ReactDOM.render((  <div className="tab">    <label htmlFor="name">姓名:</label><input id="name"/>  </div>), document.getElementById('root'))
```

1. 布尔属性

如果一个属性的值是布尔值，当这个值是true的时候则可以省略=后面的值，只保留key。

```
ReactDOM.render((  <div className="tab">    <input type="text" required/>    <input type="text" required={true}/>  </div>), document.getElementById('root'))
```

1. 原生元素的自定义属性

react对元素属性做了校验，如果在原生属性上使用此元素不支持的属性，则不能编译成功。必须使用data-前缀

```
ReactDOM.render((  <div className="tab">    <input type="text" data-init="22"/>  </div>), document.getElementById('root'))
```

## 插入html

如果动态的插入html元素,react出于安全性考虑会自动帮我们转义。所以一定要动态的插入元素的话，使用dangerouslySetInnerHTML

```
ReactDOM.render((  <div className="tab">    <div dangerouslySetInnerHTML={{__html: '<span>test</span>'}}></div>  </div>), document.getElementById('root'))
```





# React组件创建

## React.createClass

这是旧版本的api，使用React.createClass创建组件，配套的一些api，有getDefaultProps, getinitialstate。官方已经不建议使用了，使用下面新的api替代。

## ES6 classes

```
import * as React from 'react'class Page extends React.Component {  render() {    return (<div>      home    </div>)  }}
```

这是一个实现了render方法的class。也是一个基本的react组件。

## 无状态函数

```
function Button(props, context) {    return (        <button>            <em>{props.text}</em>            <span>{context.name}</span>        </button>    );}
```

纯函数,不存在state，只接受props和state。纯函数有优点，优点就是易于测试，无副作用。





# React数据流

## state

state是组件的内部状态，需要在视图里面用到的状态，才需要放到state里面去。如下，我们在类上创建一个state属性，在视图里面通过使用this.state.name去引用。而这里的state定义则代替的是getinitialstate方法。

```
import * as React from 'react'class Page extends React.Component {  state = {      name: '小明'  }      render() {    return (<div>      {this}    </div>)  }}
```

如何更新state呢，直接更改state其实可以可以的，不过这样子无法触发组件视图的更新机制。所以使用 `setState()`api。值得注意的是setState是异步的，原因是react内部需要对setState做优化，不是state变了立刻去更新视图，而是拦截一部分state的改变，等到合适的时机再去更新视图。

```
import * as React from 'react'class Page extends React.Component {  state = {      name: '小明'  }      render() {    setTimeout(() => this.setState({name: '小明儿子'})， 5000)    return (<div>      {this.state.name}    </div>)  }}
```

> *真实开发中绝不要在render函数里面去更改state，以上只是为了演示*

## props

props是组件之间传递数据的最主要api, react推崇的是自顶向下的数据流向，也就是组件的数据要从父组件传给子组件。如果子组件需要向父组件传递数据，则需要使用回调函数的方式。

```
import * as React from 'react'class Child extends React.Component {  render() {    return (<div>      {this.props.parentName}    </div>)  }}class Parent extends React.Component {  state = {      name: '小明'  }      render() {    setTimeout(() => this.setState({name: '小明儿子'})， 5000)    return (<div>      <Child parentName={this.state.name}/>    </div>)  }}
```

可以看到Child组件显示了父组件的name。当父组件状态更新了，子组件同步更新。那如何在子组件中更改父组件状态呢？答案是回调函数。

```
import * as React from 'react'class Child extends React.Component {  update() {      this.props.onChange('小明名字改了')  }  render() {    return (<div>      {this.props.parentName}      <button onClick={this.update.bind(this)}>更新</button>    </div>)  }}class Parent extends React.Component {  state = {      name: '小明'  }      changeName(name) {      this.setState({          name      })  }  render() {    setTimeout(() => this.setState({name: '小明儿子'})， 5000)    return (<div>      <Child onChange={this.changeName.bind(this)} parentName={this.state.name}/>    </div>)  }}
```

注意哈：props是不可以更改的，这既不符合react单向数据流思想，也为维护带来灾难。

### 事件

react里面的用户事件都是合成事件，被React封装过。内部使用的还是事件的委托机制。 常用的事件有点击事件onClick，input的onChange事件等，官网都可以查到。

#### 合成事件的this指向问题

就像上文一样，我们绑定事件的方式很奇怪，使用了bind来显示绑定this的指向。因为传递到组件内部的只是一个函数，而脱离了当前对象的函数的this指向是不能指到当前组件的，需要显示指定。

#### 通过bind

```
<button onClick={this.update.bind(this)}>更新</button>
```

#### 构造器内部指定

```
import * as React from 'react'class Child extends React.Component {  constructor(props) {     super(props)      this.update = this.update.bind(this)  }  update() {      this.props.onChange('小明名字改了')  }  render() {    return (<div>      {this.props.parentName}      <button onClick={this.update}>更新</button>    </div>)  }}
```

#### 箭头函数

```
import * as React from 'react'class Child extends React.Component {  update => e = {      this.props.onChange('小明名字改了')  }  render() {    return (<div>      {this.props.parentName}      <button onClick={this.update}>更新</button>    </div>)  }}
```

#### 装饰器

```
import * as React from 'react'class Child extends React.Component {  constructor(props) {     super(props)   }  @autoBind  update() {      this.props.onChange('小明名字改了')  }  render() {    return (<div>      {this.props.parentName}      <button onClick={this.update}>更新</button>    </div>)  }}
```

装饰器是es7语法，如果需要使用需要安装对应的babel：present版本。而typescript则原生支持。

> autoBind原理大概就是劫持get方法，get时改变this指向

### 如何获得evnt原生事件

通过e.nativeEvent获取原生事件对象

```
import * as React from 'react'class Child extends React.Component {  constructor(props) {     super(props)      this.update = this.update.bind(this)  }  update(e) {      console.log(e.nativeEvent)  }  render() {    return (<div>      <button onClick={this.update}>更新</button>    </div>)  }}
```

### 解决冒泡和取消默认事件

```
e.preventDefault() //取消默认行为
```

```
e.stopPropagation() //取消冒泡
```

这个和浏览器原生事件处理方案是一致的。问题是我们只可以调合成事件的 `e`的方法，不可以通过 `e.nativeEvent`方法做这些操作，原因是上文讲过的委托。

#### **判断回文字符串** 🐛

回文：回文字符串是指正着读和反着读该字符串都是相同拼写

```js
function palindrome(str){
    // \W匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。
    var re = /[\W_]/g;
    // 将字符串变成小写字符,并干掉除字母数字外的字符
    var lowRegStr = str.toLowerCase().replace(re,'');
    // 如果字符串lowRegStr的length长度为0时，字符串即是palindrome
    if(lowRegStr.length===0)
        return true;
    // 如果字符串的第一个和最后一个字符不相同，那么字符串就不是palindrome
    if(lowRegStr[0]!=lowRegStr[lowRegStr.length-1])
        return false;
    //递归
    return palindrome(lowRegStr.slice(1,lowRegStr.length-1));
}
```



#### **数组去重** 🐛

```js
function unique(arr){
    var obj = {}
    var data = []
    for(var i in arr){
        if(!obj[arr[i]]){
            obj[arr[i]] = true;
            data.push(arr[i]);
        }
    }
    return data;
}
```









# ReactDom

## ref

特殊的props，ref组件对象的引用，现在官方也不建议直接给ref赋值，需要通过函数来赋值。

```js
ReactDOM.render((  <div>    <Calendar ref={ref => this.c = ref} any-ss="text"/>  </div>), document.getElementById('root'))
```

## render

顶层api,只有在根组件时候才需要使用。第一个参数是Component,第二个参数是dom节点

## findDOMNode

通过传入component实例获取此component根dom节点，在这里可以去dom节点进行操作了，虽然极其不建议这么做，但是你确实可以做。

## unmountComponentAtNode

卸载此组件，并销毁组件state和事件

接收组件的引用，也就是ref。仅仅是取消挂载，组件还在，如果需要彻底清除的话，需要手动删掉此dom。

# 表单

## onchange配合value

与vue框架不同的是，react如果要实现表单元素变化，状态同步更新，必须要自己去监听表单事件。

```
import * as React from 'react'class Child extends React.Component {  state = {      name: '小明'  }  constructor(props) {     super(props)      this.update = this.update.bind(this)  }  update(e) {      this.setState({          name: e.target.value      })  }  render() {    return (<div>      <input onChange={this.update} value={this.state.name}/>    </div>)  }}
```

## 受控组件和非受控组件

受控组件和非受控组件这些都是指的表单组件，当一个表单的值是通过value改变的而不是通过defaultValue是受控组件，否则就是非受控组件。

下面组件中的input就是受控组件

```
import * as React from 'react'class Child extends React.Component {  state = {      name: '小明'  }  constructor(props) {     super(props)      this.update = this.update.bind(this)  }  update(e) {      this.setState({          name: e.target.value      })  }  render() {    return (<div>      <input onChange={this.update} value={this.state.name}/>    </div>)  }}
```

下面组件中的input是非受控组件

```
import * as React from 'react'class Child extends React.Component {  state = {      name: '小明'  }  constructor(props) {     super(props)      this.update = this.update.bind(this)  }  update(e) {      this.setState({          name: e.target.value      })  }  render() {    return (<div>      <input onChange={this.update} defaultValue={this.state.name}/>    </div>)  }}
```

# 组件之间通讯

## 父子之间通讯

父子之间通讯又分为父->子，子->父。

因为react单向数据流向的缘故，父->子通信的话直接通过props。父组件数据变动，直接传递给子组件。

子->父组件之间就要通过回调函数来通信了，父组件传递一个回调函数给子组件，子组件通过调用此函数的方式通知父组件通信。

## 跨级组件通信

react为了实现祖先组件和后辈组件之间的通信问题，引入了contextApi。

```
class Button extends React.Component {  render() {    return (      <button style={{background: this.context.color}}>        {this.props.children}      </button>    );  }}Button.contextTypes = {  color: React.PropTypes.string};class Message extends React.Component {  render() {    return (      <div>        {this.props.text} <Button>Delete</Button>      </div>    );  }}class MessageList extends React.Component {  getChildContext() {    return {color: "purple"};  }  render() {    const children = this.props.messages.map((message) =>      <Message text={message.text} />    );    return <div>{children}</div>;  }}MessageList.childContextTypes = {  color: React.PropTypes.string};
```

MessageList中的color会自动更新到儿孙组件里面去，实现跨级啊通信。如果需要反过来通信，则需要借助其他工具，比如事件系统(Pub/Sub)。





## 没有嵌套关系组件之间通信

组件之间通信最主流的两种方式脱胎于观察这模式和中介者模式这两种。

跨级之间通信现在最主流的方式就是观察这模式的实现Pub/Sub，react社区中的redux也是使用这种方式实现的。

vue2.X版本也去掉了跨组件通信的功能。那如何在2.x中做跨组件通信呢？如果不借助外力的话，是不是可以使用$parent和$childen的递归调用实现全局组件通信呢？比如我想广播一个事件，我就查找到所有的子组件，挨个触发$emit(xx)，上报一个事件也是同理，只不过需要查找所有的$parent。结合起来就可以实现组件之间的通信，只不过这种查找效率比较低，需要慎用和优化

> 作者：frontoldman
>
> https://segmentfault.com/a/1190000016281174





## 工作中常用到的ES6语法

JavaScript  *9月4日*

## 一、let和const

在JavaScript中咱们以前主要用关键var来定义变量，ES6之后，新增了定义变量的两个关键字，分别是let和const。 对于变量来说，在ES5中var定义的变量会提升到作用域中所有的函数与语句前面，而ES6中let定义的变量则不会，let声明的变量会在其相应的代码块中建立一个暂时性死区，直至变量被声明。 let和const都能够声明块级作用域，用法和var是类似的，let的特点是不会变量提升，而是被锁在当前块中。

一个非常简单的例子：

```
function test() {if(true) {  console.log(a)//TDZ，俗称临时死区，用来描述变量不提升的现象  let a = 1}}test()  // a is not definedfunction test() {    if(true) {      let a = 1    }    console.log(a)}    test() // a is not defined
```

**唯一正确的使用方法：先声明，再访问。**

```
function test() {    if(true) {      let a = 1      console.log(a)    }}test() // 1
```

const 声明常量，一旦声明，不可更改，而且常量必须初始化赋值。 const虽然是常量，不允许修改默认赋值，但如果定义的是对象Object，那么可以修改对象内部的属性值。

```
const type = {  a: 1}type.a = 2 //没有直接修改type的值，而是修改type.a的属性值，这是允许的。console.log(type) // {a: 2}
```

**const和let的异同点** **相同点：**const和let都是在当前块内有效，执行到块外会被销毁，也不存在变量提升（TDZ），不能重复声明。 **不同点：**const不能再赋值，let声明的变量可以重复赋值。 **const**实际上保证的，**并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动**。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。

**块级作用域的使用场景** 除了上面提到的常用声明方式，我们还可以在循环中使用，最出名的一道面试题：循环中定时器闭包的考题 在for循环中使用var声明的循环变量，会跳出循环体污染当前的函数。

```
for(var i = 0; i < 5; i++) {  setTimeout(() => {    console.log(i) //5, 5, 5, 5, 5  }, 0)}console.log(i) //5 i跳出循环体污染外部函数//将var改成let之后for(let i = 0; i < 5; i++) {  setTimeout(() => {    console.log(i) // 0,1,2,3,4  }, 0)}console.log(i)//i is not defined i无法污染外部函数
```

在实际开发中，我们选择使用var、let还是const，取决于我们的变量是不是需要更新，通常我们希望变量保证不被恶意修改，而使用大量的const。使用const声明，声明一个对象的时候，也推荐使用const，当你需要修改声明的变量值时，使用let，var能用的场景都可以使用let替代。

**symbol** ES6 以前，我们知道5种基本数据类型分别是Undefined，Null，Boolean，Number以及String，然后加上一种引用类型Object构成了JavaScript中所有的数据类型，但是ES6出来之后，新增了一种数据类型，名叫symbol，像它的名字表露的一样，意味着独一无二，意思是每个 Symbol类型都是独一无二的，不与其它 Symbol 重复。 可以通过调用 Symbol() 方法将创建一个新的 Symbol 类型的值，这个值独一无二，不与任何值相等。

```
var mySymbol=Symbol();console.log(typeof mySymbol) //"symbol"
```

## 二、字符串

ES6字符串新增的方法

**UTF-16码位：**ES6强制使用UTF-16字符串编码。关于UTF-16的解释请自行百度了解。

**codePointAt()：**该方法支持UTF-16，接受编码单元的位置而非字符串位置作为参数，返回与字符串中给定位置对应的码位，即一个整数值。

`String.fromCodePoiont()：`作用与codePointAt相反，检索字符串中某个字符的码位，也可以根据指定的码位生成一个字符。

**normalize()：**提供Unicode的标准形式，接受一个可选的字符串参数，指明应用某种Unicode标准形式。

在ES6中，新增了3个新方法。每个方法都接收2个参数，需要检测的子字符串，以及开始匹配的索引位置。

**模板字符串** 字符串是JavaScript中基本类型之一，应该算是除了对象之外是使用最为频繁的类型吧，字符串中包含了例如substr，replace，indexOf,slice等等诸多方法，ES6引入了模板字符串的特性，用反引号来表示，可以表示多行字符串以及做到文本插值（利用模板占位符）。

```
// 以前的多行字符串我们这么写：console.log("hello world 1\n\hello cala");// "hello world// hello cala"//有了模板字符串之后console.log(`hello worldstring text line 2`);// "hello world// hello cala"
```

可以用${}来表示模板占位符，可以将你已经定义好的变量传进括弧中，例如：

```
var name="cala";var age=22;console.log(`hello,I'am ${name},my age is ${age}`)//hello,I'am cala,my age is 22
```

**includes(str, index)：**如果在字符串中检测到指定文本，返回true，否则false。

```
let t = 'abcdefg'if(t.includes('cde')) {  console.log(2)}//true
```

**startsWith(str, index)：**如果在字符串起始部分检测到指定文本，返回true，否则返回false。

```
let t = 'abcdefg'if(t.startsWith('ab')) {  console.log(2)}//true
```

**endsWith(str, index)：**如果在字符串的结束部分检测到指定文本，返回true，否则返回false。

```
let t = 'abcdefg'if(t.endsWith('fg')) {  console.log(2)}//true
```

如果你只是需要匹配字符串中是否包含某子字符串，那么推荐使用新增的方法，如果需要找到匹配字符串的位置，使用indexOf()。

## 三、函数

*函数的默认参数* 在ES5中，我们给函数传参数，然后在函数体内设置默认值，如下面这种方式。

```
function a(num, callback) {  num = num || 6  callback = callback || function (data) {console.log('ES5: ', data)}  callback(num * num)}a() //ES5: 36，不传参输出默认值//你还可以这样使用callbacka(10, function(data) {  console.log(data * 10) // 1000， 传参输出新数值})
```

在ES6中，我们使用新的默认值写法

```
function a(num = 6, callback = function (data) {console.log('ES6: ', data)}) {  callback(num * num)}a() //ES6: 36， 不传参输出默认值a(10, function(data) {  console.log(data * 10) // 1000，传参输出新数值})
```

## 四、**箭头函数（=>）**

（箭头函数比较重要，现在简单提一下，迟一点有空专门写一篇箭头函数的文章。）

```
const arr = [5, 10]const s = arr.reduce((sum, item) => sum + item)console.log(s) // 15
```

箭头函数中this的使用跟普通函数也不一样，在JavaScript的普通函数中，都会有一个自己的this值，主要分为： **普通函数：** 1、函数作为全局函数被调用时，this指向全局对象 2、函数作为对象中的方法被调用时，this指向该对象 3、函数作为构造函数的时候，this指向构造函数new出来的新对象 4、还可以通过call，apply，bind改变this的指向 **箭头函数：**1、箭头函数没有this，函数内部的this来自于父级最近的非箭头函数，并且不能改变this的指向。 2、箭头函数没有super 3、箭头函数没有arguments 4、箭头函数没有new.target绑定。 5、不能使用new 6、没有原型 7、不支持重复的命名参数。

**箭头函数的简单理解**

1、箭头函数的左边表示输入的参数，右边表示输出的结果。

```
const s = a => aconsole.log(s(2)) // 2
```

2、在箭头函数中，this属于词法作用域，直接由上下文确定，对于普通函数中指向不定的this，箭头函数中处理this无疑更加简单，如下：

```
//ES5普通函数function Man(){  this.age=22;  return function(){    this.age+1;  }}var cala=new Man();console.log(cala())//undefined//ES6箭头函数function Man(){  this.age=22;  return () => this.age+1;}var cala=new Man();console.log(cala())//23
```

3、箭头函数中没有arguments(我们可以用rest参数替代),也没有原型，也不能使用new 关键字，例如：

```
//没有argumentsvar foo=(a,b)=>{return arguments[0]*arguments[1]}console.log(foo(3,5))//arguments is not defined//没有原型var Obj = () => {};console.log(Obj.prototype); // undefined//不能使用new 关键字var Obj = () => {"hello world"};var o = new Obj(); // TypeError: Obj is not a constructor
```

4、箭头函数给数组排序

```
const arr = [10, 50, 30, 40, 20]const s = arr.sort((a, b) => a - b)console.log(s) // [10,20,30,40,50]
```

**尾调用优化** 尾调用是指在函数return的时候调用一个新的函数，由于尾调用的实现需要存储到内存中，在一个循环体中，如果存在函数的尾调用，你的内存可能爆满或溢出。

ES6中，引擎会帮你做好尾调用的优化工作，你不需要自己优化，但需要满足下面3个要求： 1、函数不是闭包 2、尾调用是函数最后一条语句 3、尾调用结果作为函数返回

**尾调用实际用途——递归函数优化** 在ES5时代，我们不推荐使用递归，因为递归会影响性能。 但是有了尾调用优化之后，递归函数的性能有了提升。

```
//新型尾优化写法"use strict";  function a(n, p = 1) {  if(n <= 1) {    return 1 * p  }  let s = n * p  return a(n - 1, s)}//求 1 x 2 x 3的阶乘let sum = a(3)console.log(sum) // 6
```

## 五、ES6对象新增方法

**Object.assign()** Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。 String类型和 Symbol 类型的属性都会被拷贝。 合并对象

```
var o1 = { a: 1 };var o2 = { b: 2 };var o3 = { c: 3 };var obj = Object.assign(o1, o2, o3);console.log(obj); // { a: 1, b: 2, c: 3 }console.log(o1);  // { a: 1, b: 2, c: 3 }, 注意目标对象自身也会改变。
```

合并具有相同属性的对象

```
var o1 = { a: 1, b: 1, c: 1 };var o2 = { b: 2, c: 2 };var o3 = { c: 3 };var obj = Object.assign({}, o1, o2, o3);console.log(obj); // { a: 1, b: 2, c: 3 }
```

## 六、Map和Set

Map和Set都叫做集合，但是他们也有所不同。Set常被用来检查对象中是否存在某个键名，Map集合常被用来获取已存的信息。 Set是有序列表，含有相互独立的非重复值。**Array和Set对比** *都是一个存储多值的容器，两者可以互相转换，但是在使用场景上有区别。如下:* Array的indexOf方法比Set的has方法效率低下 Set不含有重复值（可以利用这个特性实现对一个数组的去重） Set通过delete方法删除某个值，而Array只能通过splice。两者的使用方便程度前者更优 Array的很多新方法map、filter、some、every等是Set没有的（但是通过两者可以互相转换来使用） **Object和Map对比** *Object是字符串-值，Map是值-值* Object键为string类型,Map的键是任意类型 手动计算Object尺寸,Map.size可以获取尺寸 Map的排序是插入顺序 Object有原型，所以映射中有一些缺省的键。可以理解为Map=Object.create(null)

**Set操作集合**

```
let set = new Set()// Set转化为数组let arr = Array.from(set)let arr = [...set]// 实例属性（继承自Set）set.constructor === Set set.size // 操作方法set.add(1) // 添加一个值set.delete(1) //删除一个值set.has(1) //判断是否有这个值（Array中的indexOf）set.clear() //清除所有值// 获取用于遍历的成员方法(Set的遍历顺序就是插入顺序)set.keys() // 返回键名的遍历器set.values() // 返回键值得遍历器set.entries() // 返回键值对的遍历器set.forEach() // 循环遍历每个值(和Array的方法一致)for (let key of set.keys()){}for (let val of set.values()){}for (let entry of set.entries()){}// 使用数组方法来处理set值set = new Set(arr)set = new Set([...set].map((x) => x = x * 2))set = new Set([...set].filter((x) => x > 2))
```

**Map的方法集合**

```
let map = new Map()// 实例属性(继承自Map)map.constructor === Mapmap.size// 操作方法map.set(1,2)map.get(1)map.delete(1)map.has(1)map.clear()// 遍历方法map.keys()map.values()map.entries()map.forEach()// Map和数组的转换map = new Map([['key','val'],[2,1]]) // 要求双成员数组let arr = [...map]// 值得注意的是Map的键是跟内存绑定的map.set([1], 's')map.get([1])let arr = [1]let arr1 = [1]map.set(arr, 's')map.get(arr)map.set(arr1, 's')map.get(arr1)
```

## 七、迭代器（Iterator）

**1、entries() 返回迭代器：返回键值对**

```
//数组const arr = ['a', 'b', 'c'];for(let v of arr.entries()) {  console.log(v)}// [0, 'a'] [1, 'b'] [2, 'c']//Setconst arr = new Set(['a', 'b', 'c']);for(let v of arr.entries()) {  console.log(v)}// ['a', 'a'] ['b', 'b'] ['c', 'c']//Mapconst arr = new Map();arr.set('a', 'a');arr.set('b', 'b');for(let v of arr.entries()) {  console.log(v)}// ['a', 'a'] ['b', 'b']
```

**2、values() 返回迭代器：返回键值对的value**

```
//数组const arr = ['a', 'b', 'c'];for(let v of arr.values()) {  console.log(v)}//'a' 'b' 'c'//Setconst arr = new Set(['a', 'b', 'c']);for(let v of arr.values()) {  console.log(v)}// 'a' 'b' 'c'//Mapconst arr = new Map();arr.set('a', 'a');arr.set('b', 'b');for(let v of arr.values()) {  console.log(v)}// 'a' 'b'
```

**3、keys() 返回迭代器：返回键值对的key**

```
//数组const arr = ['a', 'b', 'c'];for(let v of arr.keys()) {  console.log(v)}// 0 1 2//Setconst arr = new Set(['a', 'b', 'c']);for(let v of arr.keys()) {  console.log(v)}// 'a' 'b' 'c'//Mapconst arr = new Map();arr.set('a', 'a');arr.set('b', 'b');for(let v of arr.keys()) {  console.log(v)}// 'a' 'b'
```

虽然上面列举了3种内建的迭代器方法，但是不同集合的类型还有自己默认的迭代器，在for of中，数组和Set的默认迭代器是values()，Map的默认迭代器是entries()。

**for of循环解构**

对象本身不支持迭代，但是我们可以自己添加一个生成器，返回一个key，value的迭代器，然后使用for of循环解构key和value。

```
const obj = {  a: 1,  b: 2,  *[Symbol.iterator]() {    for(let i in obj) {      yield [i, obj[i]]    }  }}for(let [key, value] of obj) {  console.log(key, value)}// 'a' 1, 'b' 2
```

字符串迭代器

```
const str = 'abc';for(let v of str) {  console.log(v)}// 'a' 'b' 'c'
```

## ES6给数组添加了几个新方法：find()、findIndex()、fill()、copyWithin()

1、find()：传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它，并且终止搜索。

```
const arr = [1, "2", 3, 3, "2"]console.log(arr.find(n => typeof n === "number")) // 1
```

2、findIndex()：传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它的下标，终止搜索。

```
const arr = [1, "2", 3, 3, "2"]console.log(arr.findIndex(n => typeof n === "number")) // 0
```

3、fill()：用新元素替换掉数组内的元素，可以指定替换下标范围。

```
arr.fill(value, start, end)
```

4、copyWithin()：选择数组的某个下标，从该位置开始复制数组元素，默认从0开始复制。也可以指定要复制的元素范围。

```
arr.copyWithin(target, start, end)const arr = [1, 2, 3, 4, 5]console.log(arr.copyWithin(3)) // [1,2,3,1,2] 从下标为3的元素开始，复制数组，所以4, 5被替换成1, 2const arr1 = [1, 2, 3, 4, 5]console.log(arr1.copyWithin(3, 1)) // [1,2,3,2,3] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，所以4, 5被替换成2, 3const arr2 = [1, 2, 3, 4, 5]console.log(arr2.copyWithin(3, 1, 2)) // [1,2,3,2,5] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，结束位置为2，所以4被替换成2
```

ES6中类class、Promise与异步编程、代理（Proxy）和反射（Reflection）API，这几块内容比较复杂，以后有机会再详细写。

PS: 写的太匆忙了，难免有错漏的地方。

> 作者：沉静地闪光
>
> https://segmentfault.com/a/1190000016068235

## 记一次凉凉的小米前端面试

JavaScript  *8月15日*

毕业一年的跨专业萌新，在拉勾上投了武汉小米的简历，不出两天，简历被 HR 姐姐标为 “不合适”，心想自己这点履历和经验小米是看不上了。又过两天，大概晚上八九点钟，HR 姐姐突然打电话说邀请面试。也是有点奇怪。

从家到小米有两个小时车程，做公交车二层晃得竟然有点想吐了。心想做程序员一年，没学到啥高深的东西身体却不知不觉间变得这么差了；同时对此次面试也没抱太大期望，因为自身实力和小米的招聘要求还是差了一个档次。进入小米正门，左手边是小米信息部，右手边是 wps。想起来前不久在一个招聘群里面认识的 wps 的孝感老乡就在隔壁上班，也是一种缘分哈哈。

## 笔试

面试前要先做一份笔试题，题目大概是：

#### 1、爬虫引擎是怎样抓取页面的

#### 2、浏览器渲染页面的过程

1. 用户输入 URL 地址
2. 浏览器解析 URL 解析出主机名
3. 浏览器将主机名转换成服务器 ip 地址（浏览器先查找本地 DNS 缓存列表 没有的话 再向浏览器默认的 DNS 服务器发送查询请求 同时缓存）
4. 浏览器将端口号从 URL 中解析出来
5. 浏览器建立一条与目标 Web 服务器的 TCP 连接（三次握手）
6. 浏览器向服务器发送一条 HTTP 请求报文
7. 服务器向浏览器返回一条 HTTP 响应报文
8. 关闭连接 浏览器解析文档

网上找的标准答案，自己答得也是这么个意思，但是没这详细。

#### 3、异步编程的四种方法

看到这题瞬间感觉阮老师简直就是中国前端界的教父级人物啊，面试官的理想答案应该是阮老师这篇文章：Javascript 异步编程的 4 种方法。自己特地看过，也总结在我的面试题总结里面了：前端面试偏门题总结（https://www.bougieblog.cn/article/Qk9VMTlHSUU.html）。但是记性太差还是答偏了，心里恨啊。

#### 4、解释同步异步、阻塞非阻塞、并行并发之间的区别

这里补充一下并行和并发：并行是指运算中的两件或更多件事情在同一时刻发生。实事求是地说，这种情况只会在系统 CPU 拥有两个独立核心时发生，这样在任何时刻才会有不同的电脉冲信号发出。并发意味着至少两件事务在同一时间段发生。但注意，这里的事务是（高级的）任务，而不是（低级的）操作。所以，请分清并发和并行。

#### 5、js 实现数值千分位

头条笔试碰到过了： `number.toLocaleString()`

#### 6、多语言网站建设应注意哪些事项？

一开始以为多语言是 `python`、 `java`、 `php`啥的，后面面试官说是各个国家语言。

#### 7、React 非父子、兄弟组件传值

状态管理：Redux、Mobx 等等。

#### 8、"123456789876543212345678987654321..." 的第 n 位是什么？

```
function getNum(n) {    let num = 0, flag = true    for (let i = 0; i < n; i++) {        if (num === 1) flag = true        if (num === 9) flag = false flag ? num++ : num--    }    return num}
```

时间有点紧不小心把 `i<=n`写成 `i<n`了，尴尬，怪自己不细心吧。

时限是 20 分钟，还有两三题记不清了。

## 面试

面试官很亲切，说话很流畅并且肯定，感觉是个知识体系非常齐全的大牛。以下题目顺序并不是面试官问的顺序：

#### 1、浏览器打开一个页面前端缓存了哪些东西？

我：后端通过设置响应头 `CacheControl`设置资源过期时间，用于缓存一些静态资源

面试官：还有呢

我：DNS 缓存

面试官：后端缓存了什么

我：缓存了 session

面试官：还有呢

我：... 答不上来了

#### 2、说一下 vue 的生命周期

一年的 Vue 不是白用的，顺利从 `beforeCreate`到 `destroyed`过了一遍。

#### 3、你的博客用的是 Koa，Express 用过吗？

我：用过，我的个人博客本来用的是 Express，后面改成 Koa 了

面试官：为什么要改？Express 不好用吗？

我：Koa 的路由用 async 和 await 处理，不会陷入回调地狱

面试官：Express 的路由也可以封装成 asyncawait，自己试过没有？

我：没有。。。

#### 4、你的博客用的什么服务器？

我：用的 Node 服务器，pm2 做进程守护的

面试官：代码直接放上去运行的还是编译后运行的

我：（一脸懵比，脚本语言还能编译？？？）直接运行的

面试官：服务器是什么系统的？

我：windows sever...（感觉面试官笑了）

后来查了一下，segmentFault 的大佬们也说 Node JS 不用编译：运行在服务端的 Node.js 代码需要编译吗？（https://segmentfault.com/q/1010000009607720/a-1020000009607917），好想追问一下面试官到底怎么编译啊。

#### 5、有没有自己实现过 Promise？

看了不少文章，自己也写过了，但问到细节还是答烂了。

#### 6、有没有写过 Webpack 插件？

我：没有...

#### 7、new 一个对象后发生了什么？

#### 8、写过响应式网站吗？

我的个人博客就是响应式的，主要说了媒体查询和 rem 控制字体大小。

#### 9、说一下原型和原型链

#### 10、有没有自己写过比较复杂的正则？

#### 11、有没有封装过 axios？

#### 12、前后分离的系统，一个请求出错了，如何中断其它请求？

#### 13、如何在 axios 中添加登陆验证？

#### 14、rollup 了解过没？

#### 15、为什么 rollup 打包赘余代码比较少？

#### 16、有没有结合原生封装过 RN 组件？

#### 17、为什么用高德地图不用百度地图？

#### 18、怎样在 Android Studio 中对 React Native 的 js 代码进行断点调试？

......

还有 n 多问题记不太清了...

然后面试官问了一些其他的东西，对小米有什么看法？995 上班、加班没有加班费能不能接收等等。心想小米在雷总的带领下还真是拼啊。

面试聊了一个小时，很多问题答烂了，今年应该是和小米无缘了。也明显看到了自身实力的不足。很感谢面试官给我这次面试机会。

补充一个 Tips，面试时看到武汉小米开发人员操作系统清一色的是 Ubuntu，想去面试的同学最好准备一下。

> 作者：AIBBSHINBAJI
>
> https://segmentfault.com/a/1190000015716464