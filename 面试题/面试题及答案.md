  ## 前端面试题及答案

  ### 1 Doctype作用？ 严格模式与混杂模式如何区分？它们有何意义？
  （1）、 声明位于文档中的最前面，处于 标签之前。告知浏览器的解析器，用什么文档类型 规范来解析这个文档。
  （2）、严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。
  （3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。
  （4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。

  用于声明文档使用那种规范(HTML/XHTML)一般为 严格 过度 基于框架的html文档
  加入XMl声明可触发，解析方式更改为IE5.5 拥有IE5.5的bug

  ### 2 行内元素有哪些？块级元素有哪些？
  （1）CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，  比如div默认display属性值为“block”，成为“块级”元素；  span默认display属性值为“inline”，是“行内”元素。img 是行内块元素 inline-block
  （2）行内元素有：a b span input select  块级元素有：div ul ol li dl dt dd header p  

  ### 3 link 和@import 的区别是？
  （1）link属于XHTML标签，而@import是CSS提供的;
  （2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;
  （3）import只在IE5以上才能识别，而link是XHTML标签，无兼容问题;
  （4）link方式的样式的权重 高于@import的权重.

  ### 4 主流浏览器和内核分别是什么?
  IE浏览器的内核Trident、Mozilla的Gecko、Chrome的Blink（WebKit的分支）、Opera内核原为Presto，现为Blink；Safiri 浏览器

  ### 5 HTML5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？

HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。

绘画 canvas: 用于媒介回放的 video 和 audio 元素

本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；sessionStorage 的数据在浏览器关闭后自动删除

语意化更好的内容元素，比如 article、footer、header、nav、section

表单控件，calendar、date、time、email、url、search

新的技术webworker, websocket, Geolocation

  ### 6 对语义化如何理解？
用正确的标签做正确的事情！HTML语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。

  ### 7 HTML5的离线储存有几种方式？

  localStorage长期存储数据，浏览器关闭后数据不丢失；sessionStorage  数据在浏览器关闭后自动删除。


  ### 8 请描述一下 cookies，sessionStorage 和 localStorage 的区别？

cookie在浏览器和服务器间来回传递。 sessionStorage和localStorage不会。sessionStorage和localStorage的存储空间更大；sessionStorage和localStorage有更多丰富易用的接口；sessionStorage和localStorage各自独立的存储空间；

localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信
息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，
不参与和服务器的通信。

sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,
而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封
装来对Object和Array有更好的支持。

localStorage和sessionStorage使用时使用相同的API：

~~~js
localStorage.setItem("key","value");//以“key”为名称存储一个值“value”
localStorage.getItem("key");//获取名称为“key”的值
localStorage.removeItem("key");//删除名称为“key”的信息
localStorage.clear();//清空localStorage中所有信息
~~~

生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K
左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP
头中，如果使用cookie保存过多数据会带来性能问题。

三者的共同点：都是都是保存在浏览器端的，而且都是同源的！

localStorage存储有没有什么限制条件

~~~markdown
1、浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性
2、目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较
常见的JSON对象类型需要一些转换
3、localStorage在浏览器的隐私模式下面是不可读取的
4、localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡
5、localStorage不能被爬虫抓取到
~~~



### 9 iframe有那些缺点？🐛

  iframe会阻塞主页面的Onload事件；
  iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以可以绕开以上两个问题。

  ### 10 CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？

  1.id选择器（ # myid）    　　　　2.类选择器（.myclassname）    

  3.标签选择器（div, h1, p）  　 　4.相邻选择器（h1 + p）    

  5.子选择器（ul < li）    　　　  　6.后代选择器（li a）    

  7.通配符选择器（ * ）    　　　　8.属性选择器（a[rel = "external"]）    

  可继承的样式： font-size font-family color, UL LI DL DD DT;
  不可继承的样式：border padding margin width height ;
  优先级就近原则，同权重情况下样式定义最近者为准;
  载入样式以最后载入的定位为准;
  优先级为: !important >  id > class > tag     important 比 内联优先级高


  ### 11 CSS3新增伪类举例：
  p:first-of-type 选择属于其父元素的首个元素的每个元素。
  p:last-of-type  选择属于其父元素的最后元素的每个元素。
  p:only-of-type  选择属于其父元素唯一的元素的每个元素。
  p:only-child    选择属于其父元素的唯一子元素的每个元素。
  p:nth-child(2)  选择属于其父元素的第二个子元素的每个元素。
  :enabled  :disabled 控制表单控件的禁用态。
  :checked单选框或复选框被选中。

  ### 12 如何居中div？如何居中一个浮动元素？
  给div设置一个宽度，然后添加margin:0 auto属性

~~~css
div{    
  width:200px;    
  margin:0 auto; 
}
~~~

  居中一个浮动元素
  确定容器的宽高 宽500 高 300 的层  设置层的外边距 .div {   Width:500px ; height:300px;//高度可以不设  Margin: -150px 0 0 -250px;  position:relative;相对定位  background-color:pink;//方便看效果  left:50%;  top:50%;}

  列出display的值，说明他们的作用。position的值， relative和absolute定位原点是？
  　　1.block 象块类型元素一样显示。  none 缺省值。象行内元素类型一样显示。  inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。  list-item 象块类型元素一样显示，并添加样式列表标记。  

  　　2. absolute　生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。

    　　fixed （老IE不支持）        生成绝对定位的元素，相对于浏览器窗口进行定位。   
    　　relative 　生成相对定位的元素，相对于其正常位置进行定位。   
    　　static  默认值。没有定位，元素出现在正常的流中  * （忽略 top, bottom, left, right z-index 声明）。
    　　inherit 规定从父元素继承 position 属性的值。



  ### 13 为什么要初始化CSS样式？

因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。

~~~css
* {
  padding: 0;
  margin: 0;
}
/* taobao */
body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; }body, button, input, select, textarea { font:12px/1.5tahoma, arial, /5b8b/4f53; }h1, h2, h3, h4, h5, h6{ font-size:100%; }address, cite, dfn, em, var { font-style:normal; }code, kbd, pre, samp { font-family:couriernew, courier, monospace; }small{ font-size:12px; }ul, ol { list-style:none; }a { text-decoration:none; }a:hover { text-decoration:underline; }sup { vertical-align:text-top; }sub{ vertical-align:text-bottom; }legend { color:#000; }fieldset, img { border:0; }button, input, select, textarea { font-size:100%; }table { border-collapse:collapse; border-spacing:0; }
~~~


  ### 14 css定义的权重
  以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值：/* 权重为1* /div{}/* 权重为10*/.class1{}/* 权重为100*/#id1{}/* 权重为100+1=101*/#id1 div{}/* 权重为10+1=11* /.class1 div{}/* 权重为10+10+1=21*/.class1 .class2 div{} 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现

  ### 15 CSS3有哪些新特性？

  CSS3实现圆角（border-radius:8px），阴影（box-shadow:10px），  对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）  transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜  增加了更多的CSS选择器  多背景 rgba

  ### 16 介绍一下CSS的盒子模型？
  　　（1）有两种， IE 盒子模型、标准 W3C 盒子模型；IE的content部分包含了 border 和 pading;

  　　（2）盒模型： 内容(content)、内边界(padding)、外边界(margin)、 边框(border).

  ### 17 对WEB标准以及W3C的理解与认识？
  标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性;

  ### 18 XHTML和HTML有什么区别？
  HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言最主要的不同：
  XHTML 元素必须被正确地嵌套。
  XHTML 元素必须被关闭。标签名必须用小写字母。
  XHTML 文档必须拥有根元素。


  ### 26 写出几种IE6 BUG的解决方法
  1.双边距BUG float引起的 使用display
  2.3像素问题 使用float引起的 使用dislpay:inline -3px
  3.超链接hover 点击后失效 使用正确的书写顺序 link visited hover active
  4.Ie z-index问题 给父级添加position:relative
  5.Png 透明 使用js代码 改
  6.Min-height 最小高度 !Important 解决’
  7.select 在ie6下遮盖 使用iframe嵌套
  8.为什么没有办法定义1px左右的宽度容器(IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px)
  9.ie 6 不支持!important


  ### 27 img标签上title与alt属性的区别是什么?
  Alt 当图片不显示是 用文字代表。
  Title 为该属性提供信息

  ### 29 解释css sprites，如何使用。
  Css 精灵 把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量



  ### 30 浏览器标准模式和怪异模式之间的区别是什么?
  盒子模型 渲染模式的不同
  使用 window.top.document.compatMode 可显示为什么模式

  ### 31 你如何对网站的文件和资源进行优化?期待的解决方案包括：
  文件合并
  文件最小化/文件压缩
  使用CDN托管
  缓存的使用

  ### 33 清除浮动的几种方式，各自的优缺点
  1.使用空标签清除浮动 clear:both(理论上能清楚任何标签，增加无意义的标签)
  2.使用overflow:auto(空标签元素清除浮动而不得不增加无意代码的弊端,,使用zoom:1用于兼容IE)
  3.是用afert伪元素清除浮动(用于非IE浏览器)

  ### 34 javascript的typeof返回哪些数据类型
  Object number function boolean underfind

  ### 35 例举3种强制类型转换和2种隐式类型转换?
  强制（parseInt,parseFloat,number）
  隐式（== – ===）

  ### 36 split() join() 的区别 pop() push() unshift() shift()

知识点：数组和字符串常用API

split 是切割成数组的形式，join 是将数组转换成字符串

Push()尾部添加 pop()尾部删除

Unshift()头部添加 shift()头部删除



  ### 38 事件绑定和普通事件有什么区别

普通事件直接在HTML中获取事件，通常适应于简单事件单个事件（onclick）。

事件绑定可以绑定到界面中的特定元素，同一个元素可以绑定多个事件，可以绑定事件(add event lintener)，可以取消事件绑定（remove event listener），这里的功能更强大。

  ### 39 IE和DOM事件流的区别 :bug:
  1.执行顺序不一样、
  2.参数不一样
  3.事件加不加on
  4.this指向问题

事件捕获和事件冒泡：事件捕获从上层向下层捕获，事件冒泡从下层向上层冒泡。阻止默认事件或者阻止事件冒泡需要选择合适的元素进行捕获。

  ### 40 IE和标准下有哪些兼容性的写法

~~~js
var event = ev || window.event;
var ElementWidth = document.documentElement.clientWidth || document.body.clientWidth;
var target = ev.srcElement||ev.target;
~~~

  ### 41 ajax请求的时候get 和post方式的区别

  一个在url后面 一个放在虚拟载体里面 formData
  有大小限制
  安全问题

Get 通常获取请求，POST 通常是设置请求

  ### 42 call和apply的区别
  Object.call(this,obj1,obj2,obj3)
  Object.apply(this,arguments)

把一个对象的方法和属性设置到另一个对象上，实现对象的继承

  ### 43 ajax请求时，如何解释json数据 :bug:
  使用eval(现在很少使用eval方法) parse 鉴于安全性考虑 使用parse更靠谱，或者使用jsonp

  ### 44 闭包是什么，有什么特性，对页面有什么影响 :bug:
  闭包就是能够读取其他函数内部变量的函数。

  ### 45 如何阻止事件冒泡和默认事件
  cancelBubble return false

  ### 46 添加 删除 替换 插入到某个接点的方法
~~~js
obj.appendChidl
obj.innersetBefore
obj.replaceChild
obj.removeChild
~~~

  ### 47 解释jsonp的原理，以及为什么不是真正的ajax :bug:
  动态创建script标签，回调函数
  Ajax是页面无刷新请求数据操作

  ### 48 javascript的本地对象，内置对象和宿主对象 :bug:

  本地对象为array obj regexp等可以new实例化
  内置对象为gload Math 等不可以实例化的
  宿主为浏览器自带的document,window 等



  ### 49 document load 和document ready的区别
  Document.onload 是在结构和样式加载完才执行js
  Document.ready原生种没有这个方法，jquery中有 $().ready(function)

  ### 50 ”= =”和“= = =”的不同

  前者会自动转换类型
  后者不会

  ### 51 javascript的同源策略

  一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合

  ### 52 编写一个数组去重的方法
~~~js
function oSort(arr) {
  var result ={};
  var newArr=[];
  for(var i=0;i<arr.length;i++) {
    if(!result[arr[i]]) {
      newArr.push(arr[i]);
      result[arr[i]]=1;
    }
  }
  return newArr
}
~~~

  ### 53 你认为最常遇到的兼容Bug有哪些?有哪些问题是你认为解决起来最麻烦的?
  IE6 PNG
  IE6 Fixed

  ### 54 CSS定位方式有哪些?position属性的值有哪些?他们之间的区别是什么?
  在CSS中关于定位的内容是：position:relative | absolute | static | fixed
  static 没有特别的设定，遵循基本的定位规定，不能通过z-index进行层次分级。
  relative 不脱离文档流，参考自身静态位置通过 top,bottom,left,right 定位，并且可以通过z-index进行层次分级。
  absolute 脱离文档流，通过 top,bottom,left,right 定位。选53D6其最近的父级定位元素，当父级 position 为 static 时，absolute元素将以body坐标原点进行定位，可以通过z-index进行层次分级。
  fixed 固定定位，这里他所固定的对像是可视窗口而并非是body或是父级元素。可通过z-index进行层次分级。

  ### 55 函数的几种定义方法？
  function a(){},
  var a = function(){}

  ### 57 类的定义方法（prototype）（继承）
  Var a = function(){}
  a.prototype = {}
  new a();

  ### 58 this 关键字的指向
  obj.foo() == obj        //方法调用模式,this指向obj
  foo() == window;         //函数调用模式,this指向window
  new obj.foo() == obj    //构造器调用模式, this指向新建立对象
  foo.call(obj) == obj;//APPLY调用模式,this指向obj

  ### 59 异步ajax的优缺点都有什么？
  优点：
  相对于同步ajax：不会造成UI卡死，用户体验好。
  相对于刷新页面，省流量
  缺点：
   后退按钮无效；
  多个请求同时触发时，由于回调时间不确定，会造成混乱，避免这种混乱需要复杂的判断机制。
  搜索引擎不友好
  数据安全  　　

  ### 61 Javascript如何实现继承？
  通过原型和构造器

  ### 63 谈谈This对象的理解。
this是js的一个关键字，随着函数使用场合不同，this的值会发生变化。但是有一个总原则，那就是this指的是调用函数的那个对象。this一般情况下：是全局对象Global。 作为方法调用，那么this就是指这个对象

  ### 64 事件是什么？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？
  （1） 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。
  （2） 事件处理机制：IE是事件冒泡、火狐是 事件捕获；
  （3） ev.stopPropagation();

  ### 65 如何判断一个对象是否属于某个类？
  使用instanceof    if(a instanceof Person){       alert('yes');   }

  ### 66 Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？
hasOwnProperty

  ### 67 对JSON 的了解？
JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小{'age':'12', 'name':'back'}

  ### 68 简述一下src与href的区别
  href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。
  src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。

  ### 69 简述同步和异步的区别

  同步是阻塞模式，异步是非阻塞模式。
  同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；
  异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。

  ### 70 px和em的区别
px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。
浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em

  ### 71 什么叫优雅降级和渐进增强？
  渐进增强 progressive enhancement：
  针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。
  优雅降级 graceful degradation：
  一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。
  区别：
  a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给
  b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要
  c. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带

  ### 72 浏览器的内核分别是什么?
  IE: trident内核
  Firefox：gecko内核
  Safari：webkit内核
  Opera：以前是presto内核，Opera现已改用Google Chrome的Blink内核
  Chrome：Blink(基于webkit，Google与Opera Software共同开发)


  ### 73 如何消除一个数组里面重复的元素？

~~~js
// 方法一：
var arr1 =[1,2,2,2,3,3,3,4,5,6],arr2 = [];
for(var i = 0,len = arr1.length; i< len; i++){
  if(arr2.indexOf(arr1[i]) < 0){
    arr2.push(arr1[i]);
  }
}
document.write(arr2);
// 可以把重复的元素放在一个对象中；如果已经出现一次，那么就删除数组中的这个元素
~~~

  ### 74 在Javascript中什么是伪数组？如何将伪数组转化为标准数组？:bug:
伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的argument参数，还有像调用getElementsByTagName,document.childNodes之类的,它们都返回NodeList对象都属于伪数组。可以使用Array.prototype.slice.call(fakeArray)将数组转化为真正的Array对象。


```js
function log(){
  var args = Array.prototype.slice.call(arguments);  
  //为了使用unshift数组方法，将argument转化为真正的数组
  args.unshift('(app)');
  console.log.apply(console, args);
};
```
  ### 75 Javascript中callee和caller的作用？:bug:
  caller是返回一个对函数的引用，该函数调用了当前函数；
  callee是返回正在被执行的function函数，也就是所指定的function对象的正文。

  ### 76 请描述一下cookies，sessionStorage和localStorage的区别
  sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
  web storage和cookie的区别
  Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。
  除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。

  ### 77 手写数组快速排序
  关于快排算法的详细说明，可以参考阮一峰老师的文章快速排序
  “快速排序”的思想很简单，整个排序过程只需要三步：
  （1）在数据集之中，选择一个元素作为”基准”（pivot）。
  （2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。
  （3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。

  ### 78 统计字符串”aaaabbbccccddfgh”中字母个数或统计最多字母数。
  ```js
var str = "aaaabbbccccddfgh";
var obj  = {};
for(var i = 0; i < str.length; i++){
  var v = str.charAt(i);
  if (obj[v] && obj[v].value == v) {
    obj[v].count = ++ obj[v].count;
  } else {
    obj[v] = {};
    obj[v].count = 1;
    obj[v].value = v;
  }
}
for(key in obj){
  document.write(obj[key].value +'='+obj[key].count+' ');
}
  ```
  ### 79 一次完整的HTTP事务是怎样的一个过程？

  基本流程：

  a. 域名解析

  b. 发起TCP的3次握手

  c. 建立TCP连接后发起http请求

  d. 服务器端响应http请求，浏览器得到html代码

  e. 浏览器解析html代码，并请求html代码中的资源

  f. 浏览器对页面进行渲染呈现给用户



### 80、元素垂直居中

~~~css
1.css3的transform：
.ele {
     position: absolute;
     top: 50%;
     left: 50%;
     transform: translate(-50%, -50%);
}

2.flex盒子布局:
.ele {
    display: flex;
    justify-content: center;
    align-items: center;
}

3.display的table-cell:
.ele {
    display: table-cell;
    text-align: center;
    vertical-align: middle;
}

~~~



## CSS

### 81 flex 布局

~~~css
flex布局也叫弹性布局，用来为盒装模型提供最大的灵活性，任何容器都可以指定为flex布局。（display： flex/inline-flex;）
1.flex-direction属性决定主轴的方向（即项目的排列方向）。

flex-direction: row | row-reverse | column | column-reverse;

2.flex-wrap属性表示项目若不在一条抽线上时的换行方式。

flex-wrap: nowrap | wrap | wrap-reverse;

3.flex-flow属性是flex-direction和flex-wrap的简写，默认值为row nowrap。

flex-flow: < flex-direction > || < flex-wrap >;

4.justify-content属性定义类项目在主轴方向上的对齐方式。

justify-content: flex-start | flex-end | center | space-between | space-around;

5.align-items属性定义了项目在交叉轴上的对齐方式。

align-items: flex-start | flex-end | center | baseline | stretch;

6.align-content属性定义了多根轴线的对齐方式，若只有一根轴线，则该属性不起作用。

align-content: flex-start | flex-end | center | space-between | space-around | stretch;
~~~



### 82、css3中的制作动画的属性主要有哪些

##### 1.变形（transform）

①rotate(< angle >)：2D旋转，负数为逆时针旋转；
②translate(x,y)：水平和垂直方向同时移动；
③scale(< number >, < number >)：水平和垂直方向同时2D缩放；
④skew(< angle >, < angle >)：水平和垂直方向上同时扭曲；
⑤matrix(< number >, < number >，< number >, < number >，< number >, < number >)：
以一个含有六个值的变换矩阵的形式指定一个2D变换。

##### 2.转换（transition）

transition:property duration timing-function delay;
transition-property: 指css属性的name，transition的效果；
transition-duration：实现效果所需的时间；
transition-timing-function：实现效果的转速曲线；
transition-delay：定义效果开始的时间。

##### 3.动画（animation）

animation： name keeping-time animate-function delay times iteration final；
name：动画的名字；
keeping-time：动画持续时间；
animate-function：运动曲线；
delay：动画延迟时间；
times：动画循环执行的次数；
iteration：动画循环的方式；
final：动画到最后时的状态。

### 83、什么是弹性盒子？

弹性盒子是 CSS3 的一种新的布局模式。CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。

1. 弹性盒子其实是由两部分组成：弹性容器(Flex container)和弹性子元素(Flex item)。
   弹性容器：通过设置 display 属性的值为 flex 或 inline-flex 将其定义为弹性容器。
   弹性子元素：弹性容器内包含了一个或多个弹性子元素。
2. 弹性盒子的作用范围：
   弹性盒子只定义了弹性子元素如何在弹性容器内布局。也就是说，弹性容器外及弹性子元素内都是
   正常渲染的。
3. ①css 列（CSS columns）在弹性盒子中不起作用。
   ②float, clear and vertical-align 在flex项目中不起作用。
4. 弹性盒子的属性：
   ①display: flex | inline-flex; 
   ②flex-direction 
   ③flex-wrap
   ④flex-flow 
   ⑤justify-content 
   ⑥align-items 
   ⑦align-content 
   ⑧flex-grow 
   ⑨flex-basis 
   ⑩flex 



## VUE

### 1、vue的有哪些常用的指令？自定义指令是什么？

指令是一种可以附加到DOM元素的微命令(tiny commands).。它们通常以"v-"作为前缀, 以方便Vue知道你在使用一种特殊的标记, 从而确保语法的一致性。

```vue
v-if: 使用true或false来判断元素的现实或隐藏；
v-for：数据循环；
v-on：函数绑定；
v-bind：属性绑定；
v-model：数据的双向绑定。
```

以上的是vue中一些内置的指令，但在实际项目开发中这些内置指令并不能完全满足开发需求，所以可以使用vue来创建全局指令，也就是自定义指令。
举一个简单的小栗子：加载DOM时直接让表单获取焦点。

~~~vue
// 和自定义过滤器一样,我们这里定义的是全局指令
Vue.directive('focus',{
	inserted(el) {
  		el.focus()
	}
})

<input type="text" v-focus placeholder="我有v-focus,所以,我获取了焦点">

~~~

以上部分中：

①使用 Vue.directive() 来新建一个全局指令,(指令使用在HTML元素属性上的)
②Vue.directive(‘focus’) 第一个参数focus是指令名,指令名在声明的时候,不需要加 v-
③在使用指令的HTML元素上, 我们需要加上 v-.
④Vue.directive(‘focus’,{}) 第二个参数是一个对象,对象内部有个 inserted() 的函数,函数有 el 这个参数.
⑤el 这个参数表示了绑定这个指令的 DOM元素,在这里就是后面那个有 placeholder 的 input
⑥el 就等价于 document.getElementById(‘el.id’)
⑦可以利用 $(el) 无缝连接 jQuery

指令绑定到一个元素上时，指令内部的五个生命周期函数：

~~~vue
bind: 当指令绑定到 HTML 元素上时触发.只调用一次.
inserted: 当绑定了指令的这个HTML元素插入到父元素上时触发(在这里父元素是 div#app)，
但不保证，父元素已经插入了 DOM 文档.
updated: 所在组件的VNode更新时调用.
componentUpdate: 指令所在的组件的VNode以及其子VNode 全部更新后调用.
unbind: 指令和元素解绑的时候调用,只调用一次
~~~

### 2、数据双向绑定的原理

vue是一个mvvm框架，即数据双向绑定，即当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化。

VUE实现双向数据绑定的原理就是利用了 Object.defineProperty() 这个方法重新定义了对象获
取属性值(get)和设置属性值(set)的操作来实现的。

代码演示：

~~~js
defineProperty的用法var obj = { };//第一个参数：定义属性的对象。
var name;//第二个参数：要定义或修改的属性的名称。
//第三个参数：将被定义或修改的属性描述符。
Object.defineProperty(obj, "data", {
    //获取值
	get: function () {
    	return name;
	},
    //设置值set: function (val) {
	    name = val;console.log(val)
 	}
})
//赋值调用
setobj.data = 'aaa';
//取值调用
getconsole.log(obj.data);

代码演示：
defineProperty的双向绑定var obj={};
Object.defineProperty(obj, 'val',{
	set:function (newVal) {
		document.getElementById("a").value=newVal==undefined?'':newVal;
		document.getElementById("b").innerHTML=newVal==undefined?'':newVal;
	}
});
document.getElementById("a").addEventListener("keyup",function (e) {
	obj.val = e.target.value;
})
~~~


### 3、路由跳转时如何传递和接收参数
第一种params属性：

传递参数：params： {key: value}
接收参数：this.$route.params

第二种query属性：

~~~vue
传递参数：query：{key:value}
接收参数：this.$route.query
~~~

四、`$route` 和 $router的区别

1、router是VueRouter的一个对象，通过Vue.use(VueRouter)和VueRouter构造函数得到一个 router的实例对象，这个对象中是一个全局的对象，他包含了所有的路由包含了许多关键的对象
和属性。

举个栗子：history对象
```vue
$router.push({path:'home'}); //本质是向history栈中添加一个路由，在我们看来是切换路由,
但本质是在添加一个history记录

$router.replace({path:'home'}); //替换路由，没有历史记录
```

2、route是一个跳转的路由对象，每一个路由都会有一个route对象，是一个局部的对象，可以
获取对应的name,path,params,query等。



## JS

### 1、递归

递归是一种重要的编程技术，用于让一个函数从其内部调用其自身（简单说就是自己调用自己）。
构成递归需具备的条件：

1. 子问题须与原始问题为同样的事，且更为简单；
2. 不能无限制地调用本身，须有个出口，化简为非递归状况处理。

### 2、冒泡排序和快速排序

1.冒泡排序的思想：

通过相邻两个元素之间的比较和交换，使较大的元素逐渐从前面移向后面（升
序），就像水底下的气泡一样逐渐向上冒泡，所以被称为“冒泡”排序。冒泡排序的最坏时间复杂度
为O(n2)，平均时间复杂度为O(n2)。

```js
var arr=[2,5,4,1,7,3,8,6,9,0];
function arrayMax(arr) {
    var temp = null;
    for (var i = 0;i<arr.length-1;i++){
        for (var j = i+1;j<arr.length;j++){
        	//如果前面的数据比后面的大就交换  
        	//两个数交换一定要声明一个变量,用来存储其中要被赋值的那个
            if (arr[i]>arr[j]){
                temp = arr[j];
                arr[j] = arr[i];
                arr[i] = temp;
            }

        }
    }
    return arr;
}
console.log(arrayMax(arr));
```

2.快速排序的思想：

元素的比较和交换是从两端向中间进行的，较大的元素一轮就能够交换到后面的位置，而较小的元素
一轮就能交换到前面的位置，元素每次移动的距离较远，所以比较次数和移动次数较少，速度较快，
故称为“快速排序”。 

```js
var times = 0;
function queryArrayMax(arr) {
    //如果数组长度小于等于1无需判断直接返回即可
    if (arr.length<=1){
        return arr;
    }
    var arrIndex = Math.floor(arr.length/2);//获取中间值 这个是索引
    var arrCenterVal = arr.splice(arrIndex,1);// 利用索引取出中间值  改变原始数组
    var left= [],//存储小的
        right = [];//存储大的
   // 遍历数组 ,进行判断分配
   for (var i = 0;i<arr.length;i++){
       if (arr[i]<arrCenterVal){
            left.push(arr[i])//比中间值小的放在左边数组
       }else{
           right.push(arr[i])//比中间值大的放在右边数组
       }
       console.log("第"+(++times)+"次排序后："+arr);
   }
    //递归执行以上操作,对左右两个数组进行操作，直到数组长度为<=1；
   return queryArrayMax(left).concat(arrCenterVal,queryArrayMax(right))

}
console.log(queryArrayMax(arr));
```

### 3、同源策略是什么？

同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能会受到影响。所谓的同源就是指域名、协议和端口这三者一样。

解决办法：

①jsonp
②< script >标签中的src属性
③CROS（跨域资源共享）

四、说一下同步和异步

同步：同步方法表明调用一旦开始，调用者必须等待方法执行完成，才能继续执行后续方法。

JavaScript的同步：如果在函数返回结果的时候，调用者能够拿到预期的结果(就是函数计算
的结果)，那么这个函数就是同步的.

异步：方法一旦开始，立即返回，调用者无需等待其中方法执行完成，就可以继续执行后续方法。

JavaScript的异步：如果在函数返回的时候，调用者还不能购得到预期结果，而是将来通过一定的
手段得到（例如回调函数），这就是异步（例如ajax操作）。

如果函数是同步的，即使调用函数执行任务比较耗时，也会一致等待直到得到执行结果。

如果函数是异步的，发出调用之后，马上返回，但是不会马上返回预期结果。调用者不必主动等待，当被调用者得到结果之后会通过回调函数主动通知调用者。

### 5、ES6中的箭头函数和普通函数有什么区别？

箭头函数：

let fun = () => {
	console.log('lalalala');
}

普通函数：

function fun() {
	console.log('lalla');
}

① 箭头函数是匿名函数，不能作为构造函数，不能使用new
② 箭头函数不绑定arguments，取而代之用rest参数（…）解决
③ 箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值（重点）
代码演示：

```js
箭头函数：
var obj = {
	a: 10,
	b: () => {
		console.log(this.a); // undefined
		console.log(this); // Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: 
		ƒ, frames: 	Window, …}
	},
	c: function() {
		console.log(this.a); // 10
		console.log(this); // {a: 10, b: ƒ, c: ƒ}
	}
}
obj.b(); 
obj.c();

普通函数：
var obj = {
	a: 10,
	b: function(){
		console.log(this.a); //10
	},
	c: function() {
 		return ()=>{
       		console.log(this.a); //10
 		}
	}
}
obj.b(); 
obj.c()();

```

④ 箭头函数通过 call() 或 apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响
⑤ 箭头函数没有原型属性（prototype）
⑥ 箭头函数不能当做Generator函数,不能使用yield关键字

### 6、promise什么？怎么使用？

Promise是异步编程的一种解决方案，在ES6中Promise被列为了正式规范，统一了用法，原生提供了Promise对象。使用详情请查看文章：https://www.cnblogs.com/sweeeper/p/8442613.html

### 7、浏览器的内核

①IE浏览器内核：Trident内核，也是俗称的IE内核；
②Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核；
③Firefox浏览器内核：Gecko内核，俗称Firefox内核；
④Safari浏览器内核：Webkit内核；
⑤Opera浏览器内核：最初是自己的Presto内核，后来是Webkit，现在是Blink内核；
⑥360浏览器、猎豹浏览器内核：IE+Chrome双内核；
⑦搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）；
⑧百度浏览器、世界之窗内核：IE内核；
⑨2345浏览器内核：以前是IE内核，现在也是IE+Chrome双内核；