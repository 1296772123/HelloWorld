### 阿里前端要求

职位描述：

1. 负责移动端信息流推荐/搜索，以及PC端管理后台交互功能的构建

2. 参与整体项目计划制定，项目需求分析，跟踪项目进度，评估项目风险，对产品及运营需求进行技术方案设计、实现与持续优化；

3. 过程中，对业务目标及技术目标的达成负责，对问题快速响应，利用工程化的手段提高研发效率、质量。



任职要求：

1. 三年以上 Web 前端研发经验，参与过比较复杂的前端交互场景，熟练掌握 HTML/CSS/JavaScript；

2. 前端框架：VUE or React 

3. 具备前端全栈开发能力，熟练掌握Node.js 以及脚手架Express or Koa ，熟悉 Linux 系统运维； 





## 掌握react，这一篇就够了





# jsx语法

前端MVVM主流框架都有一套自己的模板处理方法，react则使用它独特的jsx语法。在组件中插入html类似的语法，简化创建view的流程。

下面让我们来认识一下构建的两种元素

## 原生元素

```
ReactDOM.render((  <div>    <h1>标题</h1>  </div>), document.getElementById('root'))
```

通过简单的语法页面就会被插入一个div+一个h1标签。原生的html元素可以被直接使用。以上的语法并不是js支持的语法，需要被转换之后才能运行。

## 自定义元素

react强大之处就在于可以组件的自定义，实现组件的复用。如果我们创建了一个组件。我们也可以通过jsx语法调用。

```
import * as React from 'react'class Page extends React.Component {  render() {    return (<div>      home111 &copy; © \ua9    </div>)  }}ReactDOM.render((  <div>    <Page/>  </div>), document.getElementById('root'))
```

我们定义了一个Page组件，可以在jsx里面像调用html一样直接调用。

## 插入动态数据

```
let name = 'hi'ReactDOM.render((  <div>    {name}  </div>), document.getElementById('root'))
```

使用{}就可以插入数据，但是{}中间的必须是js表达式，不能是语句。如果表达式的执行结果是一个数组，则会自动join。

## 注释

jsx语法和html语法一样，也是可以插入注释，只不过写的时候有一些区别

### 子组件注释

```
let name = 'hi'ReactDOM.render((  <div>    {/* 注释 */}    {name}  </div>), document.getElementById('root'))
```

在子组件中插入注释，需要使用{}包裹起来，在//之间插入注释文字。

### 属性注释

```
let name = 'hi'ReactDOM.render((  <div>    {name}    <img /*         多行注释    */ src="1.jpg"/>  </div>), document.getElementById('root'))
```

在标签中间，可以插入一个多行注释，类似上面的代码。

## 属性props

1. 可以向使用html的attr一样使用属性，就像下面img的src一样

```
let name = 'hi'ReactDOM.render((  <div>    <img src="1.png"/>  </div>), document.getElementById('root'))
```

1. 如果需要传递动态属性，使用{}，多个属性，使用展开运算符

```
let props = {    src: '1.png',    alt: '1图片'}ReactDOM.render((  <div>    <img src={"1.png"}/>    <img {...props}/>  </div>), document.getElementById('root'))
```

1. 两个转换,class-->className for-->htmlFor

因为class和for是javascript关键字，所以这里需要用转换之后名称

```
ReactDOM.render((  <div className="tab">    <label htmlFor="name">姓名:</label><input id="name"/>  </div>), document.getElementById('root'))
```

1. 布尔属性

如果一个属性的值是布尔值，当这个值是true的时候则可以省略=后面的值，只保留key。

```
ReactDOM.render((  <div className="tab">    <input type="text" required/>    <input type="text" required={true}/>  </div>), document.getElementById('root'))
```

1. 原生元素的自定义属性

react对元素属性做了校验，如果在原生属性上使用此元素不支持的属性，则不能编译成功。必须使用data-前缀

```
ReactDOM.render((  <div className="tab">    <input type="text" data-init="22"/>  </div>), document.getElementById('root'))
```

## 插入html

如果动态的插入html元素,react出于安全性考虑会自动帮我们转义。所以一定要动态的插入元素的话，使用dangerouslySetInnerHTML

```
ReactDOM.render((  <div className="tab">    <div dangerouslySetInnerHTML={{__html: '<span>test</span>'}}></div>  </div>), document.getElementById('root'))
```





# React组件创建

## React.createClass

这是旧版本的api，使用React.createClass创建组件，配套的一些api，有getDefaultProps, getinitialstate。官方已经不建议使用了，使用下面新的api替代。

## ES6 classes

```
import * as React from 'react'class Page extends React.Component {  render() {    return (<div>      home    </div>)  }}
```

这是一个实现了render方法的class。也是一个基本的react组件。

## 无状态函数

```
function Button(props, context) {    return (        <button>            <em>{props.text}</em>            <span>{context.name}</span>        </button>    );}
```

纯函数,不存在state，只接受props和state。纯函数有优点，优点就是易于测试，无副作用。





# React数据流

## state

state是组件的内部状态，需要在视图里面用到的状态，才需要放到state里面去。如下，我们在类上创建一个state属性，在视图里面通过使用this.state.name去引用。而这里的state定义则代替的是getinitialstate方法。

```
import * as React from 'react'class Page extends React.Component {  state = {      name: '小明'  }      render() {    return (<div>      {this}    </div>)  }}
```

如何更新state呢，直接更改state其实可以可以的，不过这样子无法触发组件视图的更新机制。所以使用 `setState()`api。值得注意的是setState是异步的，原因是react内部需要对setState做优化，不是state变了立刻去更新视图，而是拦截一部分state的改变，等到合适的时机再去更新视图。

```
import * as React from 'react'class Page extends React.Component {  state = {      name: '小明'  }      render() {    setTimeout(() => this.setState({name: '小明儿子'})， 5000)    return (<div>      {this.state.name}    </div>)  }}
```

> *真实开发中绝不要在render函数里面去更改state，以上只是为了演示*

## props

props是组件之间传递数据的最主要api, react推崇的是自顶向下的数据流向，也就是组件的数据要从父组件传给子组件。如果子组件需要向父组件传递数据，则需要使用回调函数的方式。

```
import * as React from 'react'class Child extends React.Component {  render() {    return (<div>      {this.props.parentName}    </div>)  }}class Parent extends React.Component {  state = {      name: '小明'  }      render() {    setTimeout(() => this.setState({name: '小明儿子'})， 5000)    return (<div>      <Child parentName={this.state.name}/>    </div>)  }}
```

可以看到Child组件显示了父组件的name。当父组件状态更新了，子组件同步更新。那如何在子组件中更改父组件状态呢？答案是回调函数。

```
import * as React from 'react'class Child extends React.Component {  update() {      this.props.onChange('小明名字改了')  }  render() {    return (<div>      {this.props.parentName}      <button onClick={this.update.bind(this)}>更新</button>    </div>)  }}class Parent extends React.Component {  state = {      name: '小明'  }      changeName(name) {      this.setState({          name      })  }  render() {    setTimeout(() => this.setState({name: '小明儿子'})， 5000)    return (<div>      <Child onChange={this.changeName.bind(this)} parentName={this.state.name}/>    </div>)  }}
```

注意哈：props是不可以更改的，这既不符合react单向数据流思想，也为维护带来灾难。

### 事件

react里面的用户事件都是合成事件，被React封装过。内部使用的还是事件的委托机制。 常用的事件有点击事件onClick，input的onChange事件等，官网都可以查到。

#### 合成事件的this指向问题

就像上文一样，我们绑定事件的方式很奇怪，使用了bind来显示绑定this的指向。因为传递到组件内部的只是一个函数，而脱离了当前对象的函数的this指向是不能指到当前组件的，需要显示指定。

#### 通过bind

```
<button onClick={this.update.bind(this)}>更新</button>
```

#### 构造器内部指定

```
import * as React from 'react'class Child extends React.Component {  constructor(props) {     super(props)      this.update = this.update.bind(this)  }  update() {      this.props.onChange('小明名字改了')  }  render() {    return (<div>      {this.props.parentName}      <button onClick={this.update}>更新</button>    </div>)  }}
```

#### 箭头函数

```
import * as React from 'react'class Child extends React.Component {  update => e = {      this.props.onChange('小明名字改了')  }  render() {    return (<div>      {this.props.parentName}      <button onClick={this.update}>更新</button>    </div>)  }}
```

#### 装饰器

```
import * as React from 'react'class Child extends React.Component {  constructor(props) {     super(props)   }  @autoBind  update() {      this.props.onChange('小明名字改了')  }  render() {    return (<div>      {this.props.parentName}      <button onClick={this.update}>更新</button>    </div>)  }}
```

装饰器是es7语法，如果需要使用需要安装对应的babel：present版本。而typescript则原生支持。

> autoBind原理大概就是劫持get方法，get时改变this指向

### 如何获得evnt原生事件

通过e.nativeEvent获取原生事件对象

```
import * as React from 'react'class Child extends React.Component {  constructor(props) {     super(props)      this.update = this.update.bind(this)  }  update(e) {      console.log(e.nativeEvent)  }  render() {    return (<div>      <button onClick={this.update}>更新</button>    </div>)  }}
```

### 解决冒泡和取消默认事件

```
e.preventDefault() //取消默认行为
```

```
e.stopPropagation() //取消冒泡
```

这个和浏览器原生事件处理方案是一致的。问题是我们只可以调合成事件的 `e`的方法，不可以通过 `e.nativeEvent`方法做这些操作，原因是上文讲过的委托。

#### **判断回文字符串** 🐛

回文：回文字符串是指正着读和反着读该字符串都是相同拼写

```js
function palindrome(str){
    // \W匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。
    var re = /[\W_]/g;
    // 将字符串变成小写字符,并干掉除字母数字外的字符
    var lowRegStr = str.toLowerCase().replace(re,'');
    // 如果字符串lowRegStr的length长度为0时，字符串即是palindrome
    if(lowRegStr.length===0)
        return true;
    // 如果字符串的第一个和最后一个字符不相同，那么字符串就不是palindrome
    if(lowRegStr[0]!=lowRegStr[lowRegStr.length-1])
        return false;
    //递归
    return palindrome(lowRegStr.slice(1,lowRegStr.length-1));
}
```



#### **数组去重** 🐛

```js
function unique(arr){
    var obj = {}
    var data = []
    for(var i in arr){
        if(!obj[arr[i]]){
            obj[arr[i]] = true;
            data.push(arr[i]);
        }
    }
    return data;
}
```





# ReactDom

## ref

特殊的props，ref组件对象的引用，现在官方也不建议直接给ref赋值，需要通过函数来赋值。

```js
ReactDOM.render((  <div>    <Calendar ref={ref => this.c = ref} any-ss="text"/>  </div>), document.getElementById('root'))
```

## render

顶层api,只有在根组件时候才需要使用。第一个参数是Component,第二个参数是dom节点

## findDOMNode

通过传入component实例获取此component根dom节点，在这里可以去dom节点进行操作了，虽然极其不建议这么做，但是你确实可以做。

## unmountComponentAtNode

卸载此组件，并销毁组件state和事件

接收组件的引用，也就是ref。仅仅是取消挂载，组件还在，如果需要彻底清除的话，需要手动删掉此dom。

# 表单

## onchange配合value

与vue框架不同的是，react如果要实现表单元素变化，状态同步更新，必须要自己去监听表单事件。

```
import * as React from 'react'class Child extends React.Component {  state = {      name: '小明'  }  constructor(props) {     super(props)      this.update = this.update.bind(this)  }  update(e) {      this.setState({          name: e.target.value      })  }  render() {    return (<div>      <input onChange={this.update} value={this.state.name}/>    </div>)  }}
```

## 受控组件和非受控组件

受控组件和非受控组件这些都是指的表单组件，当一个表单的值是通过value改变的而不是通过defaultValue是受控组件，否则就是非受控组件。

下面组件中的input就是受控组件

```
import * as React from 'react'class Child extends React.Component {  state = {      name: '小明'  }  constructor(props) {     super(props)      this.update = this.update.bind(this)  }  update(e) {      this.setState({          name: e.target.value      })  }  render() {    return (<div>      <input onChange={this.update} value={this.state.name}/>    </div>)  }}
```

下面组件中的input是非受控组件

```
import * as React from 'react'class Child extends React.Component {  state = {      name: '小明'  }  constructor(props) {     super(props)      this.update = this.update.bind(this)  }  update(e) {      this.setState({          name: e.target.value      })  }  render() {    return (<div>      <input onChange={this.update} defaultValue={this.state.name}/>    </div>)  }}
```

# 组件之间通讯

## 父子之间通讯

父子之间通讯又分为父->子，子->父。

因为react单向数据流向的缘故，父->子通信的话直接通过props。父组件数据变动，直接传递给子组件。

子->父组件之间就要通过回调函数来通信了，父组件传递一个回调函数给子组件，子组件通过调用此函数的方式通知父组件通信。

## 跨级组件通信

react为了实现祖先组件和后辈组件之间的通信问题，引入了contextApi。

```
class Button extends React.Component {  render() {    return (      <button style={{background: this.context.color}}>        {this.props.children}      </button>    );  }}Button.contextTypes = {  color: React.PropTypes.string};class Message extends React.Component {  render() {    return (      <div>        {this.props.text} <Button>Delete</Button>      </div>    );  }}class MessageList extends React.Component {  getChildContext() {    return {color: "purple"};  }  render() {    const children = this.props.messages.map((message) =>      <Message text={message.text} />    );    return <div>{children}</div>;  }}MessageList.childContextTypes = {  color: React.PropTypes.string};
```

MessageList中的color会自动更新到儿孙组件里面去，实现跨级啊通信。如果需要反过来通信，则需要借助其他工具，比如事件系统(Pub/Sub)。





## 没有嵌套关系组件之间通信

组件之间通信最主流的两种方式脱胎于观察这模式和中介者模式这两种。

跨级之间通信现在最主流的方式就是观察这模式的实现Pub/Sub，react社区中的redux也是使用这种方式实现的。

vue2.X版本也去掉了跨组件通信的功能。那如何在2.x中做跨组件通信呢？如果不借助外力的话，是不是可以使用$parent和$childen的递归调用实现全局组件通信呢？比如我想广播一个事件，我就查找到所有的子组件，挨个触发$emit(xx)，上报一个事件也是同理，只不过需要查找所有的$parent。结合起来就可以实现组件之间的通信，只不过这种查找效率比较低，需要慎用和优化

> 作者：frontoldman
>
> https://segmentfault.com/a/1190000016281174





## 工作中常用到的ES6语法

JavaScript  *9月4日*

## 一、let和const

在JavaScript中咱们以前主要用关键var来定义变量，ES6之后，新增了定义变量的两个关键字，分别是let和const。 对于变量来说，在ES5中var定义的变量会提升到作用域中所有的函数与语句前面，而ES6中let定义的变量则不会，let声明的变量会在其相应的代码块中建立一个暂时性死区，直至变量被声明。 let和const都能够声明块级作用域，用法和var是类似的，let的特点是不会变量提升，而是被锁在当前块中。

一个非常简单的例子：

```
function test() {if(true) {  console.log(a)//TDZ，俗称临时死区，用来描述变量不提升的现象  let a = 1}}test()  // a is not definedfunction test() {    if(true) {      let a = 1    }    console.log(a)}    test() // a is not defined
```

**唯一正确的使用方法：先声明，再访问。**

```
function test() {    if(true) {      let a = 1      console.log(a)    }}test() // 1
```

const 声明常量，一旦声明，不可更改，而且常量必须初始化赋值。 const虽然是常量，不允许修改默认赋值，但如果定义的是对象Object，那么可以修改对象内部的属性值。

```
const type = {  a: 1}type.a = 2 //没有直接修改type的值，而是修改type.a的属性值，这是允许的。console.log(type) // {a: 2}
```

**const和let的异同点** **相同点：**const和let都是在当前块内有效，执行到块外会被销毁，也不存在变量提升（TDZ），不能重复声明。 **不同点：**const不能再赋值，let声明的变量可以重复赋值。 **const**实际上保证的，**并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动**。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。

**块级作用域的使用场景** 除了上面提到的常用声明方式，我们还可以在循环中使用，最出名的一道面试题：循环中定时器闭包的考题 在for循环中使用var声明的循环变量，会跳出循环体污染当前的函数。

```
for(var i = 0; i < 5; i++) {  setTimeout(() => {    console.log(i) //5, 5, 5, 5, 5  }, 0)}console.log(i) //5 i跳出循环体污染外部函数//将var改成let之后for(let i = 0; i < 5; i++) {  setTimeout(() => {    console.log(i) // 0,1,2,3,4  }, 0)}console.log(i)//i is not defined i无法污染外部函数
```

在实际开发中，我们选择使用var、let还是const，取决于我们的变量是不是需要更新，通常我们希望变量保证不被恶意修改，而使用大量的const。使用const声明，声明一个对象的时候，也推荐使用const，当你需要修改声明的变量值时，使用let，var能用的场景都可以使用let替代。

**symbol** ES6 以前，我们知道5种基本数据类型分别是Undefined，Null，Boolean，Number以及String，然后加上一种引用类型Object构成了JavaScript中所有的数据类型，但是ES6出来之后，新增了一种数据类型，名叫symbol，像它的名字表露的一样，意味着独一无二，意思是每个 Symbol类型都是独一无二的，不与其它 Symbol 重复。 可以通过调用 Symbol() 方法将创建一个新的 Symbol 类型的值，这个值独一无二，不与任何值相等。

```
var mySymbol=Symbol();console.log(typeof mySymbol) //"symbol"
```

## 二、字符串

ES6字符串新增的方法

**UTF-16码位：**ES6强制使用UTF-16字符串编码。关于UTF-16的解释请自行百度了解。

**codePointAt()：**该方法支持UTF-16，接受编码单元的位置而非字符串位置作为参数，返回与字符串中给定位置对应的码位，即一个整数值。

`String.fromCodePoiont()：`作用与codePointAt相反，检索字符串中某个字符的码位，也可以根据指定的码位生成一个字符。

**normalize()：**提供Unicode的标准形式，接受一个可选的字符串参数，指明应用某种Unicode标准形式。

在ES6中，新增了3个新方法。每个方法都接收2个参数，需要检测的子字符串，以及开始匹配的索引位置。

**模板字符串** 字符串是JavaScript中基本类型之一，应该算是除了对象之外是使用最为频繁的类型吧，字符串中包含了例如substr，replace，indexOf,slice等等诸多方法，ES6引入了模板字符串的特性，用反引号来表示，可以表示多行字符串以及做到文本插值（利用模板占位符）。

```
// 以前的多行字符串我们这么写：console.log("hello world 1\n\hello cala");// "hello world// hello cala"//有了模板字符串之后console.log(`hello worldstring text line 2`);// "hello world// hello cala"
```

可以用${}来表示模板占位符，可以将你已经定义好的变量传进括弧中，例如：

```
var name="cala";var age=22;console.log(`hello,I'am ${name},my age is ${age}`)//hello,I'am cala,my age is 22
```

**includes(str, index)：**如果在字符串中检测到指定文本，返回true，否则false。

```
let t = 'abcdefg'if(t.includes('cde')) {  console.log(2)}//true
```

**startsWith(str, index)：**如果在字符串起始部分检测到指定文本，返回true，否则返回false。

```
let t = 'abcdefg'if(t.startsWith('ab')) {  console.log(2)}//true
```

**endsWith(str, index)：**如果在字符串的结束部分检测到指定文本，返回true，否则返回false。

```
let t = 'abcdefg'if(t.endsWith('fg')) {  console.log(2)}//true
```

如果你只是需要匹配字符串中是否包含某子字符串，那么推荐使用新增的方法，如果需要找到匹配字符串的位置，使用indexOf()。

## 三、函数

*函数的默认参数* 在ES5中，我们给函数传参数，然后在函数体内设置默认值，如下面这种方式。

```
function a(num, callback) {  num = num || 6  callback = callback || function (data) {console.log('ES5: ', data)}  callback(num * num)}a() //ES5: 36，不传参输出默认值//你还可以这样使用callbacka(10, function(data) {  console.log(data * 10) // 1000， 传参输出新数值})
```

在ES6中，我们使用新的默认值写法

```
function a(num = 6, callback = function (data) {console.log('ES6: ', data)}) {  callback(num * num)}a() //ES6: 36， 不传参输出默认值a(10, function(data) {  console.log(data * 10) // 1000，传参输出新数值})
```

## 四、**箭头函数（=>）**

（箭头函数比较重要，现在简单提一下，迟一点有空专门写一篇箭头函数的文章。）

```
const arr = [5, 10]const s = arr.reduce((sum, item) => sum + item)console.log(s) // 15
```

箭头函数中this的使用跟普通函数也不一样，在JavaScript的普通函数中，都会有一个自己的this值，主要分为： **普通函数：** 1、函数作为全局函数被调用时，this指向全局对象 2、函数作为对象中的方法被调用时，this指向该对象 3、函数作为构造函数的时候，this指向构造函数new出来的新对象 4、还可以通过call，apply，bind改变this的指向 **箭头函数：**1、箭头函数没有this，函数内部的this来自于父级最近的非箭头函数，并且不能改变this的指向。 2、箭头函数没有super 3、箭头函数没有arguments 4、箭头函数没有new.target绑定。 5、不能使用new 6、没有原型 7、不支持重复的命名参数。

**箭头函数的简单理解**

1、箭头函数的左边表示输入的参数，右边表示输出的结果。

```
const s = a => aconsole.log(s(2)) // 2
```

2、在箭头函数中，this属于词法作用域，直接由上下文确定，对于普通函数中指向不定的this，箭头函数中处理this无疑更加简单，如下：

```
//ES5普通函数function Man(){  this.age=22;  return function(){    this.age+1;  }}var cala=new Man();console.log(cala())//undefined//ES6箭头函数function Man(){  this.age=22;  return () => this.age+1;}var cala=new Man();console.log(cala())//23
```

3、箭头函数中没有arguments(我们可以用rest参数替代),也没有原型，也不能使用new 关键字，例如：

```
//没有argumentsvar foo=(a,b)=>{return arguments[0]*arguments[1]}console.log(foo(3,5))//arguments is not defined//没有原型var Obj = () => {};console.log(Obj.prototype); // undefined//不能使用new 关键字var Obj = () => {"hello world"};var o = new Obj(); // TypeError: Obj is not a constructor
```

4、箭头函数给数组排序

```
const arr = [10, 50, 30, 40, 20]const s = arr.sort((a, b) => a - b)console.log(s) // [10,20,30,40,50]
```

**尾调用优化** 尾调用是指在函数return的时候调用一个新的函数，由于尾调用的实现需要存储到内存中，在一个循环体中，如果存在函数的尾调用，你的内存可能爆满或溢出。

ES6中，引擎会帮你做好尾调用的优化工作，你不需要自己优化，但需要满足下面3个要求： 1、函数不是闭包 2、尾调用是函数最后一条语句 3、尾调用结果作为函数返回

**尾调用实际用途——递归函数优化** 在ES5时代，我们不推荐使用递归，因为递归会影响性能。 但是有了尾调用优化之后，递归函数的性能有了提升。

```
//新型尾优化写法"use strict";  function a(n, p = 1) {  if(n <= 1) {    return 1 * p  }  let s = n * p  return a(n - 1, s)}//求 1 x 2 x 3的阶乘let sum = a(3)console.log(sum) // 6
```

## 五、ES6对象新增方法

**Object.assign()** Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。 String类型和 Symbol 类型的属性都会被拷贝。 合并对象

```
var o1 = { a: 1 };var o2 = { b: 2 };var o3 = { c: 3 };var obj = Object.assign(o1, o2, o3);console.log(obj); // { a: 1, b: 2, c: 3 }console.log(o1);  // { a: 1, b: 2, c: 3 }, 注意目标对象自身也会改变。
```

合并具有相同属性的对象

```
var o1 = { a: 1, b: 1, c: 1 };var o2 = { b: 2, c: 2 };var o3 = { c: 3 };var obj = Object.assign({}, o1, o2, o3);console.log(obj); // { a: 1, b: 2, c: 3 }
```

## 六、Map和Set

Map和Set都叫做集合，但是他们也有所不同。Set常被用来检查对象中是否存在某个键名，Map集合常被用来获取已存的信息。 Set是有序列表，含有相互独立的非重复值。**Array和Set对比** *都是一个存储多值的容器，两者可以互相转换，但是在使用场景上有区别。如下:* Array的indexOf方法比Set的has方法效率低下 Set不含有重复值（可以利用这个特性实现对一个数组的去重） Set通过delete方法删除某个值，而Array只能通过splice。两者的使用方便程度前者更优 Array的很多新方法map、filter、some、every等是Set没有的（但是通过两者可以互相转换来使用） **Object和Map对比** *Object是字符串-值，Map是值-值* Object键为string类型,Map的键是任意类型 手动计算Object尺寸,Map.size可以获取尺寸 Map的排序是插入顺序 Object有原型，所以映射中有一些缺省的键。可以理解为Map=Object.create(null)

**Set操作集合**

```
let set = new Set()// Set转化为数组let arr = Array.from(set)let arr = [...set]// 实例属性（继承自Set）set.constructor === Set set.size // 操作方法set.add(1) // 添加一个值set.delete(1) //删除一个值set.has(1) //判断是否有这个值（Array中的indexOf）set.clear() //清除所有值// 获取用于遍历的成员方法(Set的遍历顺序就是插入顺序)set.keys() // 返回键名的遍历器set.values() // 返回键值得遍历器set.entries() // 返回键值对的遍历器set.forEach() // 循环遍历每个值(和Array的方法一致)for (let key of set.keys()){}for (let val of set.values()){}for (let entry of set.entries()){}// 使用数组方法来处理set值set = new Set(arr)set = new Set([...set].map((x) => x = x * 2))set = new Set([...set].filter((x) => x > 2))
```

**Map的方法集合**

```
let map = new Map()// 实例属性(继承自Map)map.constructor === Mapmap.size// 操作方法map.set(1,2)map.get(1)map.delete(1)map.has(1)map.clear()// 遍历方法map.keys()map.values()map.entries()map.forEach()// Map和数组的转换map = new Map([['key','val'],[2,1]]) // 要求双成员数组let arr = [...map]// 值得注意的是Map的键是跟内存绑定的map.set([1], 's')map.get([1])let arr = [1]let arr1 = [1]map.set(arr, 's')map.get(arr)map.set(arr1, 's')map.get(arr1)
```

## 七、迭代器（Iterator）

**1、entries() 返回迭代器：返回键值对**

```
//数组const arr = ['a', 'b', 'c'];for(let v of arr.entries()) {  console.log(v)}// [0, 'a'] [1, 'b'] [2, 'c']//Setconst arr = new Set(['a', 'b', 'c']);for(let v of arr.entries()) {  console.log(v)}// ['a', 'a'] ['b', 'b'] ['c', 'c']//Mapconst arr = new Map();arr.set('a', 'a');arr.set('b', 'b');for(let v of arr.entries()) {  console.log(v)}// ['a', 'a'] ['b', 'b']
```

**2、values() 返回迭代器：返回键值对的value**

```
//数组const arr = ['a', 'b', 'c'];for(let v of arr.values()) {  console.log(v)}//'a' 'b' 'c'//Setconst arr = new Set(['a', 'b', 'c']);for(let v of arr.values()) {  console.log(v)}// 'a' 'b' 'c'//Mapconst arr = new Map();arr.set('a', 'a');arr.set('b', 'b');for(let v of arr.values()) {  console.log(v)}// 'a' 'b'
```

**3、keys() 返回迭代器：返回键值对的key**

```
//数组const arr = ['a', 'b', 'c'];for(let v of arr.keys()) {  console.log(v)}// 0 1 2//Setconst arr = new Set(['a', 'b', 'c']);for(let v of arr.keys()) {  console.log(v)}// 'a' 'b' 'c'//Mapconst arr = new Map();arr.set('a', 'a');arr.set('b', 'b');for(let v of arr.keys()) {  console.log(v)}// 'a' 'b'
```

虽然上面列举了3种内建的迭代器方法，但是不同集合的类型还有自己默认的迭代器，在for of中，数组和Set的默认迭代器是values()，Map的默认迭代器是entries()。

**for of循环解构**

对象本身不支持迭代，但是我们可以自己添加一个生成器，返回一个key，value的迭代器，然后使用for of循环解构key和value。

```
const obj = {  a: 1,  b: 2,  *[Symbol.iterator]() {    for(let i in obj) {      yield [i, obj[i]]    }  }}for(let [key, value] of obj) {  console.log(key, value)}// 'a' 1, 'b' 2
```

字符串迭代器

```
const str = 'abc';for(let v of str) {  console.log(v)}// 'a' 'b' 'c'
```

## ES6给数组添加了几个新方法：find()、findIndex()、fill()、copyWithin()

1、find()：传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它，并且终止搜索。

```
const arr = [1, "2", 3, 3, "2"]console.log(arr.find(n => typeof n === "number")) // 1
```

2、findIndex()：传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它的下标，终止搜索。

```
const arr = [1, "2", 3, 3, "2"]console.log(arr.findIndex(n => typeof n === "number")) // 0
```

3、fill()：用新元素替换掉数组内的元素，可以指定替换下标范围。

```
arr.fill(value, start, end)
```

4、copyWithin()：选择数组的某个下标，从该位置开始复制数组元素，默认从0开始复制。也可以指定要复制的元素范围。

```
arr.copyWithin(target, start, end)const arr = [1, 2, 3, 4, 5]console.log(arr.copyWithin(3)) // [1,2,3,1,2] 从下标为3的元素开始，复制数组，所以4, 5被替换成1, 2const arr1 = [1, 2, 3, 4, 5]console.log(arr1.copyWithin(3, 1)) // [1,2,3,2,3] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，所以4, 5被替换成2, 3const arr2 = [1, 2, 3, 4, 5]console.log(arr2.copyWithin(3, 1, 2)) // [1,2,3,2,5] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，结束位置为2，所以4被替换成2
```

ES6中类class、Promise与异步编程、代理（Proxy）和反射（Reflection）API，这几块内容比较复杂，以后有机会再详细写。

PS: 写的太匆忙了，难免有错漏的地方。

> 作者：沉静地闪光
>
> https://segmentfault.com/a/1190000016068235
